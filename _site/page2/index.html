<!DOCTYPE html>
<html>
<head>

  <meta charset="UTF-8">
  <title>Solar Theme</title>
  <meta name="viewport" content="width=device-width">

  <!--[if lt IE 9]>
    <script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="/assets/css/style.css" rel="stylesheet" />
  <link href="/assets/css/colors-dark.css" rel="stylesheet" />

</head>

<body>



  <header id="header">
    <h1><a href="/"><i class="icon-sun"></i> Solar Theme</a></h1>
    <p>A stylish blog using the Solarized color palette</p>
  </header>



  <div id="page">



    <div id="sidebar">
      <nav>
        <ul>
          <li><a href="/">Home</a></li>
          <li><a href="/archives">Archive</a></li>
          <li><a href="/about">About</a></li>
          <li><a href="http://twitter.com/redwall_hp">Twitter</a></li>
          <li><a href="/feed.xml">RSS Feed</a></li>
        </ul>
      </nav>
    </div>



    <div id="content">
      

	<article class="post">

		
			<h1><a href="/2016/12/07/Android%E5%B8%B8%E7%94%A8adb-shell%E5%91%BD%E4%BB%A4/">Android常用adb shell命令</a></h1>
		

		<div class="post-content"><p>调试Android程序有时需要adb shell命令，adb全称Android Debug Bridge，就是起到调试桥的作用。通过adb我们可以在Eclipse中通过DDMS来调试Android程序，说白了就是debug工具。adb通过监听Socket TCP 5554等端口让IDE和Qemu通讯。默认情况下当我们运行Eclipse时adb进程就会自动运行。adb是一个C/S模式的程序，由三个部分组成：a client，a server and a daemon。其中client和server运行在的development machine上，daemon运行在emulator或设备上。</p>
<p>adb一般位于/platform-tools/目录下，其中是android sdk的安装目录。可以把adb路径添加进系统环境变量path里面，例：D:\sdk\platform-tools;这样就能在打开powershell时就能响应adb命令，不用每次都进入adb目录。以下是常用adb命令<br />
adb常用命令<br />
显示系统中全部Android平台：<br />
android list targets<br />
显示系统中全部AVD(模拟器)：<br />
android list avd<br />
创建AVD(模拟器)：<br />
android create avd –name 名称 –target 平台编号<br />
启动模拟器：<br />
emulator -avd 名称 -sdcard ~/名称.img (-skin 1280×800)<br />
删除AVD(模拟器)：<br />
android delete avd –name 名称<br />
创建SDCard：<br />
mksdcard 1024M ~/名称.img<br />
AVD(模拟器)所在位置：<br />
Linux(~/.android/avd) Windows(C:\Documents and Settings\Administrator&#46;android\avd)<br />
启动DDMS：<br />
ddms<br />
显示当前运行的全部模拟器：<br />
adb devices<br />
对某一模拟器执行命令：<br />
abd -s 模拟器编号 命令<br />
安装应用程序：<br />
adb install -r 应用程序.apk<br />
获取模拟器中的文件：<br />
adb pull  &lt;remote&gt;&lt;local&gt;<br />
向模拟器中写文件：<br />
adb push  &lt;local&gt; &lt;remote&gt;<br />
进入模拟器的shell模式：<br />
adb shell<br />
启动SDK，文档，实例下载管理器：<br />
android<br />
缷载apk包：<br />
adb shell&nbsp;<br />
cd data/app&nbsp;<br />
rm apk包&nbsp;<br />
exit&nbsp;<br />
adb uninstall apk包的主包名&nbsp;<br />
adb install -r apk包<br />
查看adb命令帮助信息：<br />
adb help<br />
在命令行中查看LOG信息：<br />
adb logcat -s 标签名<br />
adb shell后面跟的命令主要来自：<br />
源码\system\core\toolbox目录和源码\frameworks\base\cmds目录。<br />
删除系统应用：<br />
adb remount （重新挂载系统分区，使系统分区重新可写）。<br />
adb shell&nbsp;<br />
cd system/app<br />
rm *.apk<br />
获取管理员权限：<br />
adb root<br />
启动Activity：<br />
adb shell am start -n 包名/包名+类名(-n 类名,-a action,-d date,-m MIME-TYPE,-c category,-e 扩展数据,等)。<br />
发布端口：<br />
你可以设置任意的端口号，做为主机向模拟器或设备的请求端口。如：<br />
&nbsp;adb forward tcp:5555 tcp:8000<br />
复制文件：<br />
你可向一个设备或从一个设备中复制文件，<br />
复制一个文件或目录到设备或模拟器上：&nbsp;<br />
adb push &lt;source&gt;&lt;destination&gt;&lt;/destination&gt;&lt;/source&gt;<br />
如：adb push test.txt /tmp/test.txt&nbsp;<br />
从设备或模拟器上复制一个文件或目录：&nbsp;<br />
adb pull &nbsp;&nbsp;<br />
如：adb pull /addroid/lib/libwebcore.so .<br />
搜索模拟器/设备的实例：<br />
取得当前运行的模拟器/设备的实例的列表及每个实例的状态：&nbsp;<br />
adb devices<br />
查看bug报告：<br />
adb bugreport<br />
记录无线通讯日志：<br />
一般来说，无线通讯的日志非常多，在运行时没必要去记录，但我们还是可以通过命令，设置记录：&nbsp;<br />
adb shell&nbsp;<br />
logcat -b radio<br />
获取设备的ID和序列号：<br />
adb get-product&nbsp;<br />
adb get-serialno<br />
访问数据库SQLite3<br />
adb shell&nbsp;<br />
sqlite3<br />
cd system/sd/data //进入系统内指定文件夹<br />
ls //列表显示当前文件夹内容<br />
rm -r xxx //删除名字为xxx的文件夹及其里面的所有文件<br />
rm xxx //删除文件xxx<br />
rmdir xxx //删除xxx的文件夹</p>
</div>

	</article>



	<article class="post">

		
			<h1><a href="/2016/11/29/Rxtx%E5%9C%A8%E5%AE%89%E5%8D%93%E4%B8%8B%E7%9A%84%E4%BD%BF%E7%94%A8/">Rxtx在安卓下的使用</a></h1>
		

		<div class="post-content"><h3>什么是Rxtx</h3>
<pre><code>RXTX项目提供了Windows,Linux,Mac os X,Solaris操作系统下的兼容javax.comm
串口通讯包API的实现，为其他研发人员在此类系统下研发串口应用提供了相当的方便。

RXTX是个提供串口和并口通信的开源java类库，由该项目发布的文档均遵循LGPL协议。
针对x86体系结构的Linux操作系统平台，RXTX的部署包括下面几个文档：
* RXTXcomm.jar RXTX自己的实现
* librxtxSerial.so 由调用的底层串口库文档
* librxtxParallel.so 由RXTXcomm.jar调用的底层并口库文档
驱动的类配置文档,内容是Driver=gnu.io.RXTXCommDriver


--------------------------------------------------------------------
以上是来自百度百科的解释，可以看见Rxtx是适用于Windows，Linux，Mac OS等系统的串口
通讯包，并未包含Android系统。
有大神已经实现了将Rxtx用于安卓系统上：http://v-lad.org/projects/gnu.io.android/

Github地址：https://github.com/vladistan/gnu.io.android
</code></pre>
<h3>使用方法</h3>
<pre><code>在需要使用Rxtx的安卓设备/system/etc/ 目录下创建文件：gnu.io.rxtx.properties，在文件中写入：
gnu.io.rxtx.SerialPorts=/dev/ttyUSB3:/dev/ttyUSB4

其中/dev/ttyUSB3和/dev/ttyUSB4表示串口设备在文件系统下的挂载点。

将项目中提供的so库文件放到自己的项目中，在Android Studio中对应的目录为jniLibs
然后将对应的java类导入项目，就可以正常使用了。

如果使用过程中发生错误，请注意在Logcat中查看，可能是由于目录读写权限引起的错误。
比如程序需要有权限读取写入：/data/local目录。

</code></pre>
<h3>补充</h3>
<pre><code>修改目录权限时如果遇到&amp;quot;... Read-only file system&amp;quot;。

解决办法：
1. 最简单的，adb remount
2. 不行的话，adb shell su之后将文件系统remount为读写权限： mount -o remount rw /system。出于安全考虑，记得完事后remount回只读： mount -o ro,remount /system
3. 和方法2类似，mount -o rw,remount -t ext3 /dev/block/mmcblk1p21 /system


Rxtx可配合Modbus4J使用。 关于Modbus4J可查看我的另一篇文章：http://donute.com/?p=153
</code></pre>
</div>

	</article>



	<article class="post">

		
			<h1><a href="/2016/11/16/Node.js%E9%80%9A%E8%BF%87Restful-Api%E4%B8%8EBmob%E5%90%8E%E7%AB%AF%E4%BA%91%E4%BA%A4%E4%BA%92/">Node.js通过Restful Api与Bmob后端云交互</a></h1>
		

		<div class="post-content"><h3>关于Bmob</h3>
<pre><code>[Bmob](<a href="http://www.bmob.cn">http://www.bmob.cn</a>)
百度百科：
Bmob可以开发一个云存储的移动应用软件，给应用软件快速添加一个安全灵活的后台管理系统，方便浏览终端保存的各种信息。

Bmob特点
对于很多Android/ios/wp个人移动开发者来说，开发一个具有网络功能的应用不是一件
容易的事，不仅需要购买/租赁服务器，还必须掌握一门诸如Java/.net/php这类的服务
器开发语言，每开发一款移动应用程序，就必须开发维护对应的服务器程序。这一切对于
移动开发者来说，都是一个冗长的噩梦。
如何让移动开发者从繁琐的机械劳动中解脱出来，将更多精力投入到移动应用程序的创意
研发，从而不断提升产品质量呢？Bmob移动应用云存储平台的诞生就很好地解决了以上难
题。
在Bmob平台上，您只需注册一个帐号，成功后申请创建任意多个数据库，获得对应的
Key，下载对应版本的SDK并将其嵌入到移动应用中，便可以调用存取API，进行数据的任
意操作。有了Bmob，您在5分钟内就可以学会如何开发一个云存储的移动应用软件，给应
用软件快速添加一个安全灵活的后台管理系统，方便您浏览终端保存的各种信息。
</code></pre>
<h3>开始使用</h3>
<pre><code>首先按照Bmob的文档申请账号，创建应用：
<a href="http://docs.bmob.cn/data/Android/a_faststart/doc/index.html">http://docs.bmob.cn/data/Android/a_faststart/doc/index.html</a>

下面代码演示了使用Node.js查询并删除数据：
 var http = require(&amp;#039;https&amp;#039;);
var qs = require(&amp;#039;querystring&amp;#039;);
var deleteOptions = {           //删除请求的options
    &amp;quot;method&amp;quot;: &amp;quot;DELETE&amp;quot;,
    &amp;quot;hostname&amp;quot;: &amp;quot;api.bmob.cn&amp;quot;,
    &amp;quot;headers&amp;quot;: {
        &amp;quot;x-bmob-application-id&amp;quot;: &amp;quot;这里填写ApplicationId&amp;quot;,
        &amp;quot;x-bmob-rest-api-key&amp;quot;: &amp;quot;这里填写Rest-Api_key&amp;quot;
    }
};
var queryOptions={              //查询请求的options
    &amp;quot;method&amp;quot;: &amp;quot;GET&amp;quot;,
    &amp;quot;hostname&amp;quot;: &amp;quot;api.bmob.cn&amp;quot;,
    &amp;quot;headers&amp;quot;: {
        &amp;quot;x-bmob-application-id&amp;quot;: &amp;quot;这里填写ApplicationId&amp;quot;,
        &amp;quot;x-bmob-rest-api-key&amp;quot;: &amp;quot;这里填写Rest-Api_key&amp;quot;,
        &amp;quot;content-type&amp;quot;: &amp;quot;application/json&amp;quot;,
    }
}
function query(tableName) {     //查询函数
    queryOptions.path=&amp;quot;/1/classes/&amp;quot;+tableName   //拼接查询path
    var req = http.request(queryOptions, function (res) { //发起请求
        var chunks = [];
        res.setEncoding(&amp;#039;utf8&amp;#039;);
        res.on(&amp;#039;data&amp;#039;, function (chunk) {    //数据返回时回调
            chunks.push(chunk)      
        });
        res.on(&amp;#039;end&amp;#039;,function () {        //数据返回结束时回调
            var body=&amp;quot;&amp;quot;;
            for(i=0;i&amp;lt;chunks.length;i++){
                body=body+chunks[i]
            }
            var results=JSON.parse(body)
            var day15=1000*60*60*24*15
            for(j=0;j&amp;lt;results.results.length;j++){       
                var obj=results.results[j]
                var createdTime=new Date(obj.createdAt).getTime();
                var now=new Date().getTime();
                var liveTime=now-createdTime;
                if (liveTime&amp;gt;day15){          //时间检查，删除15天以前的记录
                    deleteRow(obj.objectId,tableName)
                }
            }
        })
    });
    req.on(&amp;#039;error&amp;#039;, function (e) {            //请求错误时回调
        console.log(&amp;#039;problem with request: &amp;#039; + e.message);
    });
    req.end();
}
function deleteRow(objectId,tableName){     //删除记录函数
    deleteOptions.path=&amp;quot;/1/classes/&amp;quot;+tableName+&amp;quot;/&amp;quot;+objectId      //拼接删除path
    var req = http.request(deleteOptions, function (res) {      //发起DELETE请求
        var chunks = [];
        res.setEncoding(&amp;#039;utf8&amp;#039;);
        res.on(&amp;#039;data&amp;#039;, function (chunk) {
            chunks.push(chunk)
        });
        res.on(&amp;#039;end&amp;#039;,function () {
            var body=&amp;quot;&amp;quot;;
            for(i=0;i&amp;lt;chunks.length;i++){
                body=body+chunks[i]
            }
            console.log(tableName+&amp;quot;:&amp;quot;+objectId+&amp;quot;       &amp;quot;+body);
        })
    });
    req.on(&amp;#039;error&amp;#039;, function (e) {
        console.log(&amp;#039;problem with request: &amp;#039; + e.message);
    });
    req.end();
}
function start() {          //开始执行
    var tables=[&amp;quot;TableName1&amp;quot;,&amp;quot;TableName2&amp;quot;,&amp;quot;TableName3&amp;quot;];  //需要删除记录的表名
    for(i=0;i&amp;lt;tables.length;i++){
        query(tables[i])
        console.log(&amp;#039;start query:&amp;#039;+tables[i]);
    }
}
setInterval(start,6000);        //每分钟执行
</code></pre>
</div>

	</article>



	<article class="post">

		
			<h1><a href="/2016/11/15/Modbus4J%E5%9C%A8%E5%AE%89%E5%8D%93%E7%B3%BB%E7%BB%9F%E4%B8%8B%E7%9A%84%E4%BD%BF%E7%94%A8/">Modbus4J在安卓系统下的使用</a></h1>
		

		<div class="post-content"><h3>一.Modbus协议</h3>
<pre><code>1.Modbus是由Modicon（现为施耐德电气公司的一个品牌）在1979年发明的，是全球第一个真正用于工业现场的总线协议。
ModBus网络是一个工业通信系统，由带智能终端的可编程序控制器和计算机通过公用线路或局部专用线路连接而成。其系统结构既包括硬件、亦包括软件。它可应用于各种数据采集和过程监控。
ModBus网络只有一个主机，所有通信都由他发出。网络可支持247个之多的远程从属控制器，但实际所支持的从机数要由所用通信设备决定。采用这个系统，各PC可以和中心主机交换信息而不影响各PC执行本身的控制任务。

2.Modbus具有以下几个特点：
（1）标准、开放，用户可以免费、放心地使用Modbus协议，不需要交纳许可证费，也不会侵犯知识产权。目前，支持Modbus的厂家超过400家，支持Modbus的产品超过600种。
（2）Modbus可以支持多种电气接口，如RS-232、RS-485等，还可以在各种介质上传送，如双绞线、光纤、无线等。
（3）Modbus的帧格式简单、紧凑，通俗易懂。用户使用容易，厂商开发简单。

3.ModBus功能码
01  READ COIL STATUS
02  READ INPUT STATUS
03  READ HOLDING REGISTER
04  READ INPUT REGISTER
05  WRITE SINGLE COIL
06  WRITE SINGLE REGISTER
15  WRITE MULTIPLE COIL
16  WRITE MULTIPLE REGISTER
</code></pre>
<h3>二.Modbus4J简介</h3>
<pre><code>[Git](https://github.com/infiniteautomation/modbus4j)
以下是Git上Modbus4J的简介：
modbus4j
========
A high-performance and ease-of-use implementation of the Modbus protocol written in Java by Infinite Automation Systems and Serotonin Software. Supports ASCII, RTU, TCP, and UDP transports as slave or master, automatic request partitioning and response data type parsing.
Commercial licenses are available from www.InfiniteAutomation.com

Modbus4J是一个由英菲尼迪自动化系统和Serotonin软件一起推出的高性能且易于使用的基于java语言的Modbus协议的实现。支持主/从站，ASCII，RTU，TCP和UDP传输方式，具有自动化的请求分割与响应数据解析的功能。
</code></pre>
<h3>三.在安卓下使用Modbus4J</h3>
<pre><code>    /**
     * 初始化Modbus主站
     */
    public static void initModbusMaster() {
        String plcIpAddress= AppSP.getStringValue(AppSP.PLC_IP_ADDRESS,&amp;quot;&amp;quot;);
        String plcPort= AppSP.getStringValue(AppSP.PLC_PORT,&amp;quot;502&amp;quot;);//PLC端口号默认502
        plcNO=Integer.parseInt(AppSP.getStringValue(AppSP.PLC_NO,&amp;quot;1&amp;quot;));//默认PLC站号为1
        if(plcIpAddress.equals(&amp;quot;&amp;quot;)||plcPort.equals(&amp;quot;&amp;quot;)){
            return;
        }

        IpParameters ipParameters=new IpParameters();
        ipParameters.setHost(plcIpAddress);
        ipParameters.setPort(Integer.parseInt(plcPort));
        if(master!=null){
            if (master.isInitialized()){
                master.destroy();
            }
        }

        ModbusFactory modbusFactory = new ModbusFactory();
        master = modbusFactory.createTcpMaster(ipParameters,true);
        new Thread(){
            @Override
            public void run() {
                super.run();
                try {
                    master.init();
                } catch (ModbusInitException e) {
                    e.printStackTrace();
                }finally {
                    master.destroy();
                }
            }
        }.start();
    }


    在安卓上使用Modbus4J，Modbus可以使用串口或者以太网通信，这里我们使用的是以太网通信方式：
public class ModbusBridge {
    /**
     * 读保持寄存器上的内容
     * @param master 主站
     * @param slaveId 从站地址
     * @param start 起始地址的偏移量
     * @param len 待读寄存器的个数
     * @param listener 回调监听
     */
    public static void readHRegs(final ModbusMaster master, final int slaveId, final int start, final int len, final ModbusResponseListener listener) {
        if(master==null){
            return;
        }
        new AsyncTask&amp;lt;Object[],Long,ModbusResponse&amp;gt;(){
            @Override
            protected ModbusResponse doInBackground(Object[]... params) {
                ReadHoldingRegistersRequest request = null;
                ReadHoldingRegistersResponse response=null;
                try {
                    request = new ReadHoldingRegistersRequest(slaveId, start, len);
                    response = (ReadHoldingRegistersResponse) master.send(request);
                    return response;
                } catch (ModbusTransportException e) {
                    e.printStackTrace();
                }
                return null;
            }

            @Override
            protected void onPostExecute(ModbusResponse response) {
                super.onPostExecute(response);
                if(response==null){
                    onFail(response);
                    return;
                }
                listener.onResponse(response);
            }
        }.execute();
    }

    /**
     * 批量写数据到保持寄存器
     * @param master 主站
     * @param slaveId 从站地址
     * @param start 起始地址的偏移量
     * @param values 待写数据
     * @param listener 回调监听
     */
    public static void writeHRegs(final ModbusMaster master, final int slaveId, final int start, final short[] values, final ModbusResponseListener listener) {
        if(master==null){
            return;
        }
        new AsyncTask&amp;lt;Object[],Long,ModbusResponse&amp;gt;(){
            @Override
            protected ModbusResponse doInBackground(Object[]... params) {
                WriteRegistersRequest request ;
                WriteRegistersResponse response;
                try {
                     request = new WriteRegistersRequest(slaveId, start, values);
                     response = (WriteRegistersResponse) master.send(request);
                    return response;
                }
                catch (ModbusTransportException e) {
                    e.printStackTrace();
                }
                return null;
            }

            @Override
            protected void onPostExecute(ModbusResponse response) {
                super.onPostExecute(response);
                if(response==null){
                    onFail(response);
                    return;
                }
                listener.onResponse(response);
            }
        }.execute();
    }

    /**
     * 同步方式批量写数据到保持寄存器
     * @param master
     * @param slaveId
     * @param start
     * @param values
     */
    public static int writeHRegs(final ModbusMaster master, final int slaveId, final int start, final short[] values){
        if(master==null){
            return -1;
        }
        try {
            WriteRegistersRequest request = new WriteRegistersRequest(slaveId, start, values);
            WriteRegistersResponse response = (WriteRegistersResponse) master.send(request);
            if(!response.isException()){
                return 0;
            }else {
                return -1;
            }
        }
        catch (ModbusTransportException e) {
            e.printStackTrace();
        }
        return -1;
    }

    /************************************************************************************************************/
    /**
     * 带掩码写数据到保持寄存器
     * @param master 主站
     * @param slaveId 从站地址
     * @param start 起始地址
     * @param andMask The andMask determines which bits we want to change
     * @param orMask The orMask determines what value a bit will have after writing
     * @param listener 回调监听
     */
    public static void writeMaskReg(final ModbusMaster master, final int slaveId, final int start, final int andMask, final int orMask, final ModbusResponseListener listener) {
        if(master==null){
            return;
        }
        readHRegs(master, slaveId, start, 1, new ModbusResponseListener() {
            @Override
            public void onResponse(ModbusResponse response) {
                if(!response.isException()){
                    short temp=((ReadHoldingRegistersResponse)response).getShortData()[0];
                    Log.d(&amp;quot;读取数据&amp;quot;,temp+&amp;quot;&amp;quot;);
                    Log.d(&amp;quot;准备数据1&amp;quot;,(temp&amp;amp;andMask)+&amp;quot;&amp;quot;);
                    Log.d(&amp;quot;准备数据2&amp;quot;,((temp&amp;amp;andMask)|orMask)+&amp;quot;&amp;quot;);
                    int result=((temp&amp;amp;andMask)|orMask);
                    short[] data={(short)result};
                    writeHRegs(master,slaveId,start,data,listener);
                }
            }
        });
    }
    private static void onFail(ModbusResponse response){
        if(response==null){
            Toast.makeText(MainApplication.getContext(),&amp;quot;ModbusTransportException&amp;quot;,Toast.LENGTH_LONG).show();
        }else {
            Toast.makeText(MainApplication.getContext(),&amp;quot;Fail:&amp;quot;+response.getExceptionMessage(),Toast.LENGTH_LONG).show();
        }
    }

    /********************************************************************************************************************/

    /**
     * 写线圈寄存器
     * @param master
     * @param slaveId
     * @param addr
     * @param value
     * @param listener
     */
    public static void writeCoilRegister(final ModbusMaster master, final int slaveId, final int addr, final boolean value, final ModbusResponseListener listener){
        if(master==null){
            return;
        }
        new AsyncTask&amp;lt;Object[],Long,ModbusResponse&amp;gt;(){
            @Override
            protected ModbusResponse doInBackground(Object[]... params) {
                WriteCoilRequest request ;
                WriteCoilResponse response;
                try {
                    request = new WriteCoilRequest(slaveId,addr,value);
                    response = (WriteCoilResponse) master.send(request);
                    return response;
                }
                catch (ModbusTransportException e) {
                    e.printStackTrace();
                }
                return null;
            }

            @Override
            protected void onPostExecute(ModbusResponse response) {
                super.onPostExecute(response);
                if(response==null){
                    onFail(response);
                    return;
                }
                listener.onResponse(response);
            }
        }.execute();
    }

    /**
     * 读线圈寄存器
     * @param master
     * @param slaveId
     * @param addr
     * @param listener
     */
    public static void readCoilRegister(final ModbusMaster master, final int slaveId, final int addr, final ModbusResponseListener listener){
        if(master==null){
            return;
        }
        new AsyncTask&amp;lt;Object[],Long,ModbusResponse&amp;gt;(){
            @Override
            protected ModbusResponse doInBackground(Object[]... params) {
                ReadCoilsRequest request = null;
                ReadCoilsResponse response=null;
                try {
                    request = new ReadCoilsRequest(slaveId,addr,1);
                    response = (ReadCoilsResponse) master.send(request);
                    return response;
                } catch (ModbusTransportException e) {
                    e.printStackTrace();
                }
                return null;
            }

            @Override
            protected void onPostExecute(ModbusResponse response) {
                super.onPostExecute(response);
                if(response==null){
                    onFail(response);
                    return;
                }
                listener.onResponse(response);
            }
        }.execute();
    }

    /**
     * 同步写线圈寄存器
     * @param master
     * @param slaveId
     * @param addr
     * @param value
     */
    public static int writeCoilRegister(final ModbusMaster master,int slaveId,int addr,boolean value){
        if(master==null){
            return -1;
        }
        try {
            WriteCoilRequest request=new WriteCoilRequest(slaveId,addr,value);
            WriteCoilResponse response= (WriteCoilResponse) master.send(request);
            if(!response.isException()){
                return 1;
            }else {
                return -1;
            }
        } catch (ModbusTransportException e) {
            e.printStackTrace();
        }
        return -1;
    }
    /**
     * 同步读线圈寄存器
     * @param master
     * @param slaveId
     * @param addr
     */
    public static boolean readCoilRegister(final ModbusMaster master,int slaveId,int addr){
        if(master==null){
            return false;
        }
        try {
            ReadCoilsRequest request=new ReadCoilsRequest(slaveId,addr,1);
            ReadCoilsResponse response= (ReadCoilsResponse) master.send(request);
            if(!response.isException()){
                return response.getBooleanData()[0];
            }
            return false;
        } catch (ModbusTransportException e) {
            e.printStackTrace();
        }
        return false;
    }

    public static void read(final ModbusMaster master,int slaveId,int addr){
        try {
            ReadCoilsRequest request2=new ReadCoilsRequest(slaveId,addr,8);
            ReadCoilsResponse response2= (ReadCoilsResponse) master.send(request2);
            if(!response2.isException()){
                Log.e(&amp;quot;ReadInputRegisters&amp;quot;,response2.getFunctionCode()+&amp;quot;   &amp;quot;+Arrays.toString(response2.getBooleanData()));
            }

        } catch (ModbusTransportException e) {
            e.printStackTrace();
        }
    }
}
</code></pre>
</div>

	</article>



	<article class="post">

		
			<h1><a href="/2016/11/14/Ubuntu%E4%B8%8BMoodle%E7%BD%91%E7%AB%99%E5%8D%87%E7%BA%A7%E7%AC%94%E8%AE%B0/">Ubuntu下Moodle网站升级笔记</a></h1>
		

		<div class="post-content"><h2>1、备份原网站文件夹。</h2>
<p>将整个网站文件夹复制到用户主目录下的backup文件夹内，以防网站升级失败用于恢复。</p>
<h2>2、下载新版moodle。</h2>
<p>访问moodle.org，下载最新版的（现在是2.7+），将下载的文件解压，并覆盖原来的网站文件夹。</p>
<h2>3、开始升级。</h2>
<p>在浏览器中访问localhost，提示安装moodle，在这个过程中要指定数据文件夹为原网站的数据文件夹，数据库为原网站的数据库名。提示是否确认升级，确认后开始进行升级要求检查，此时提示现有版本1.9不能直接升级至2.7+，返回第二步，下载2.2版moodle，重复2、3两步。</p>
<h2>4、解决数据库问题。</h2>
<p>在升级2.2的过程中，提示数据库的字符集必须为utf-8，打开ubuntu的终端，修改数据库字符集：输入 mysql –u root –p</p>
<p><wbr /> <wbr /> <wbr /> <wbr /> <wbr /> <wbr /> <wbr /> <wbr /> <wbr /> <wbr /> <wbr /> <wbr /> <wbr /> <wbr /> <wbr /> <wbr /> 输入密码</p>
<p><wbr /> <wbr /> <wbr /> <wbr /> <wbr /> <wbr /> <wbr /> <wbr /> <wbr /> <wbr /> <wbr /> <wbr /> <wbr /> <wbr /> <wbr /> <wbr /> use jsjxywklt(此处为需要修改字符集的数据库名)</p>
<p><wbr /> <wbr /> <wbr /> <wbr /> <wbr /> <wbr /> <wbr /> <wbr /> <wbr /> <wbr /> <wbr /> <wbr /> <wbr /> <wbr /> <wbr /> <wbr /> alert database <wbr /> jsjxywklt character set utf8;回车</p>
<p>数据库字符集修改完成。</p>
<h2>5、回到升级页面。</h2>
<p>回到浏览器中的升级页面，点击重新载入，这次可以看到开始升级了。</p>
<p>升级需要的时间较长，耐心等待。</p>
<p>从1.9升级至2.2以后，再可以重复以上步骤升级至2.7+。</p>
<h2>6、升级完成。</h2>
</div>

	</article>



	<article class="post">

		
			<h1><a href="/2016/11/14/Moodle%E6%95%99%E5%AD%A6%E7%BD%91%E7%AB%99%E4%BB%8Ewindows-server-2008%E7%A7%BB%E6%A4%8D%E5%88%B0ubuntu-kylin/">Moodle教学网站从windows server 2008移植到ubuntu</a></h1>
		

		<div class="post-content"><h1 align="center">Moodle教学网站从windows server 2008移植到ubuntu kylin</h1>
<h2>1、 <wbr /> <wbr /> <wbr /> <wbr /> <wbr /> <wbr /> 登录ubuntu kylin系统安装LAMP（即linux+apache+Mysql+Php）</h2>
<p>上一份文档已经详细说明了LAMP的安装过程。</p>
<h2>2、在windows下备份原网站的数据库。</h2>
<p>管理员账户登录windows server 2008服务器，进入mysql安装目录下的bin目录，在命令行窗口下运行mysqldump –u root –p jsjxywklt(不同的网站这里的名字不一样，mysql下show databases课查看所有的数据库。)&gt;C:\myqsldumpbackup\jsjxywklt.sql.</p>
<p>此处会提示输入数据库密码，正确输入以后命令开始执行。</p>
<p>等待命令执行完毕，数据库数据已经被备份到C盘下的mysqldumpbackup目录中，考入U盘备用。</p>
<h2>3、 <wbr /> <wbr /> <wbr /> <wbr /> <wbr /> <wbr /> 拷贝网站数据及相关文件</h2>
<p>在windows server 2008系统中，将要迁移的整个网站目录和数据目录拷贝到U盘备用。</p>
<h2>4、 <wbr /> <wbr /> <wbr /> <wbr /> <wbr /> <wbr /> 复制相关文件</h2>
<p>将U盘中的网站文件复制到搭建好的apache服务器的网站根目录下（例如/var/www/html）,注意，此时不要复制网站的数据文件，在复制过去的文件夹下找到config.php文件，修改wwwroot和dbhost的指向，按实际使用的目录填写。</p>
<p>特别注意要修改网站目录的权限，因此处只做测试用，可赋予最大权限即：sudo chmod –R 777 htmlmoodle安装</p>
<h2>5、完成moodle基本搭建</h2>
<p>在浏览器中输入第四步中指定好的ip地址（一般用本机地址，或localhost。），按提示走完整个安装过程。</p>
<h2>6、 <wbr /> <wbr /> <wbr /> <wbr /> <wbr /> <wbr /> 复制数据文件</h2>
<p>将安装moodle以后自动生成的数据文件夹删除，然后把原网站的数据文件拷贝至相应目录。设置好目录的访问权限。</p>
<h2>7、 <wbr /> <wbr /> <wbr /> <wbr /> <wbr /> <wbr /> 导入备份数据库</h2>
<p>最重要的一步，导入数据库。在ubuntu系统下，将第二步中拷贝的数据库备份文件复制到home目录，打开终端，输入命令：mysql –u root –p按回车。输入密码后进入数据库管理。</p>
<p>在mysql命令下输入 use jsjxywklt（不同网站的数据库名不同，此处是这次拷贝的网站的数据库名）。然后输入：source  <wbr />/home/jsjxywklt.sql按下回车键可以看到数据库开始导入了。数据库导入完成后，即可在浏览器正常访问迁移后的网站。</p>
</div>

	</article>



	<article class="post">

		
			<h1><a href="/2016/11/14/Ubuntu%E4%B8%8B%E6%90%AD%E5%BB%BAmoodle%E5%B9%B3%E5%8F%B0/">Ubuntu下 搭建moodle平台</a></h1>
		

		<div class="post-content"><div>1、安装apache2软件。</div>
<div>登录ubuntu系统，在联网的情况下打开终端，输入sudo apt-get install apache2.等待安装完成</div>
<div>2、安装Mysql软件。</div>
<div>在终端输入sudo apt-get install mysql-server，期间会提示设置数据库管理员的密码，请牢记，在第六步中需要使用。</div>
<div>3、安装php5及扩展软件。</div>
<div>在终端输入sudo apt-get install php5  <wbr />php5-curl  <wbr />phpmyadmin</div>
<div>期间需要输入mysql管理员帐号密码，并设置phpmyadmin的密码</div>
<div>装完之后重启apache2使curl启用生效：sudo /etc/init.d/apache2 restart</div>
<div>4、下载最新版的moodle。</div>
<div>进入网站http://moodle.org/download/下载最新版的moodle。我们下载使用的是：2.7+ (Build: 20140703)。下载完成后将moodle解压至apache的默认目录（/var/www/html）</div>
<div>5、修改文件夹权限。</div>
<div>将moodle所在目录修改为都可写，在终端中输入：sudo chmod -R a+w html</div>
<div>将/var目录改为可写，在终端中输入：sudo chmod a+w /var</div>
<div>6、进行moodle的设置。</div>
<div>打开浏览器，在地址栏输入：127.0.0.1  <wbr /> 回车</div>
<div>选择中文，一步一步往下设置</div>
<div>期间需要确认data文件安装位置，确认之后会安装中文语言包。如果不能自动下载，可以手动下载后解压至文件夹。</div>
<div>输入第二步中设置的mysql数据库管理员帐号密码。</div>
<div>在确认了机器配置符合最低需求之后，便开始安装。</div>
<div>大约过几分钟安装完成后，设置一下moodle管理员的帐号信息，站点信息等。</div>
<div>安装完成后，可以通过localhost访问到刚才搭建的moodle平台。</div>
<div>7、对外发布。</div>
<div>到第六步为止，moodle已经搭建完成，但是只能在本地服务器上通过127.0.0.1访问。若要在其他机器访问moodle，可以打开终端，输入sudo gedit  <wbr />/var/www/html/config.php  <wbr />  <wbr /> 这时可以看到一个文本编辑窗口，将文本中的127.0.0.1字段替换成本机IP地址即可例如：192.168.1.115.</div>
<div></div>
<div></div>
<div>如果搭建完成，在浏览器中打开页面为空白一般为文件夹权限设置错误。如果只能通过localhost访问则是由于config.php中设置不正确。</div>
</div>

	</article>



	<article class="post">

		
			<h1><a href="/2016/11/14/%E4%BD%BF%E7%94%A8html5%E7%9A%84canvas%E6%A0%87%E7%AD%BE%E5%88%B6%E4%BD%9C%E6%97%B6%E9%92%9F/">使用html5的canvas标签制作时钟。</a></h1>
		

		<div class="post-content"><p><img class="alignnone size-full wp-image-173" src="http://donute.com/wp-content/uploads/2016/11/002o3oc9gy6IpsHmh2xa1690.png" alt="002o3oc9gy6ipshmh2xa1690" width="450" height="468" /></p>
<div>
<table>
<tbody>
<tr>
<td></td>
<td>复制代码，粘贴在记事本中，另存为colock.html在浏览器中打开就可以看到效果。</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>我的html5时钟</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>width="500" height="500" id="clock" &gt;</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>function drawClock()</td>
</tr>
<tr>
<td></td>
<td>{</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>var clock=document.getElementByIdx_x('clock');</td>
</tr>
<tr>
<td></td>
<td>var cxt=clock.getContext('2d');</td>
</tr>
<tr>
<td></td>
<td>var now=new Date();</td>
</tr>
<tr>
<td></td>
<td>var sec=now.getSeconds();</td>
</tr>
<tr>
<td></td>
<td>var min=now.getMinutes();</td>
</tr>
<tr>
<td></td>
<td>var hou=now.getHours();</td>
</tr>
<tr>
<td></td>
<td>hou=hou&gt;12?(hou-12+min/60):(hou+min/60);</td>
</tr>
<tr>
<td></td>
<td>cxt.clearRect(0,0,500,500);</td>
</tr>
<tr>
<td></td>
<td>cxt.beginPath();</td>
</tr>
<tr>
<td></td>
<td>cxt.lineWidth="10";</td>
</tr>
<tr>
<td></td>
<td>cxt.strokeStyle="blue";</td>
</tr>
<tr>
<td></td>
<td>cxt.arc(250,250,200,0,360,false);</td>
</tr>
<tr>
<td></td>
<td>cxt.stroke();</td>
</tr>
<tr>
<td></td>
<td>cxt.closePath();</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>for(var i=0;i&lt;12;i++)</td>
</tr>
<tr>
<td></td>
<td>{</td>
</tr>
<tr>
<td></td>
<td>cxt.save();</td>
</tr>
<tr>
<td></td>
<td>cxt.translate(250,250);</td>
</tr>
<tr>
<td></td>
<td>cxt.strokeStyle="black";</td>
</tr>
<tr>
<td></td>
<td>cxt.lineWidth="9";</td>
</tr>
<tr>
<td></td>
<td>cxt.rotate(i*30*Math.PI/180);</td>
</tr>
<tr>
<td></td>
<td>cxt.beginPath();</td>
</tr>
<tr>
<td></td>
<td>cxt.moveTo(0,-197);</td>
</tr>
<tr>
<td></td>
<td>cxt.lineTo(0,-180);</td>
</tr>
<tr>
<td></td>
<td>cxt.stroke();</td>
</tr>
<tr>
<td></td>
<td>cxt.closePath();</td>
</tr>
<tr>
<td></td>
<td>cxt.restore();</td>
</tr>
<tr>
<td></td>
<td>}</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>for(var i=0;i&lt;60;i++)</td>
</tr>
<tr>
<td></td>
<td>{</td>
</tr>
<tr>
<td></td>
<td>cxt.save();</td>
</tr>
<tr>
<td></td>
<td>cxt.translate(250,250);</td>
</tr>
<tr>
<td></td>
<td>cxt.strokeStyle="black";</td>
</tr>
<tr>
<td></td>
<td>cxt.lineWidth="3";</td>
</tr>
<tr>
<td></td>
<td>cxt.rotate(i*6*Math.PI/180);</td>
</tr>
<tr>
<td></td>
<td>cxt.beginPath();</td>
</tr>
<tr>
<td></td>
<td>cxt.moveTo(0,-197);</td>
</tr>
<tr>
<td></td>
<td>cxt.lineTo(0,-188);</td>
</tr>
<tr>
<td></td>
<td>cxt.stroke();</td>
</tr>
<tr>
<td></td>
<td>cxt.closePath();</td>
</tr>
<tr>
<td></td>
<td>cxt.restore();</td>
</tr>
<tr>
<td></td>
<td>}</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>cxt.beginPath();</td>
</tr>
<tr>
<td></td>
<td>cxt.lineWidth="10";</td>
</tr>
<tr>
<td></td>
<td>cxt.save();</td>
</tr>
<tr>
<td></td>
<td>cxt.translate(250,250);</td>
</tr>
<tr>
<td></td>
<td>cxt.strokeStyle="green";</td>
</tr>
<tr>
<td></td>
<td>cxt.beginPath();</td>
</tr>
<tr>
<td></td>
<td>cxt.rotate(hou*30*Math.PI/180);</td>
</tr>
<tr>
<td></td>
<td>cxt.stroke();</td>
</tr>
<tr>
<td></td>
<td>cxt.closePath();</td>
</tr>
<tr>
<td></td>
<td>cxt.moveTo(0,10);</td>
</tr>
<tr>
<td></td>
<td>cxt.lineTo(0,-80);</td>
</tr>
<tr>
<td></td>
<td>cxt.stroke();</td>
</tr>
<tr>
<td></td>
<td>cxt.closePath();</td>
</tr>
<tr>
<td></td>
<td>cxt.restore();</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>cxt.beginPath();</td>
</tr>
<tr>
<td></td>
<td>cxt.lineWidth="6";</td>
</tr>
<tr>
<td></td>
<td>cxt.save();</td>
</tr>
<tr>
<td></td>
<td>cxt.translate(250,250);</td>
</tr>
<tr>
<td></td>
<td>cxt.strokeStyle="orange";</td>
</tr>
<tr>
<td></td>
<td>cxt.beginPath();</td>
</tr>
<tr>
<td></td>
<td>cxt.rotate(min*6*Math.PI/180);</td>
</tr>
<tr>
<td></td>
<td>cxt.stroke();</td>
</tr>
<tr>
<td></td>
<td>cxt.closePath();</td>
</tr>
<tr>
<td></td>
<td>cxt.moveTo(0,10);</td>
</tr>
<tr>
<td></td>
<td>cxt.lineTo(0,-120);</td>
</tr>
<tr>
<td></td>
<td>cxt.stroke();</td>
</tr>
<tr>
<td></td>
<td>cxt.closePath();</td>
</tr>
<tr>
<td></td>
<td>cxt.restore();</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>cxt.beginPath();</td>
</tr>
<tr>
<td></td>
<td>cxt.lineWidth="3";</td>
</tr>
<tr>
<td></td>
<td>cxt.save();</td>
</tr>
<tr>
<td></td>
<td>cxt.translate(250,250);</td>
</tr>
<tr>
<td></td>
<td>cxt.strokeStyle="red";</td>
</tr>
<tr>
<td></td>
<td>cxt.beginPath();</td>
</tr>
<tr>
<td></td>
<td>cxt.rotate(sec*6*Math.PI/180);</td>
</tr>
<tr>
<td></td>
<td>cxt.stroke();</td>
</tr>
<tr>
<td></td>
<td>cxt.closePath();</td>
</tr>
<tr>
<td></td>
<td>cxt.moveTo(0,10);</td>
</tr>
<tr>
<td></td>
<td>cxt.lineTo(0,-150);</td>
</tr>
<tr>
<td></td>
<td>cxt.stroke();</td>
</tr>
<tr>
<td></td>
<td>cxt.closePath();</td>
</tr>
<tr>
<td></td>
<td>cxt.beginPath();</td>
</tr>
<tr>
<td></td>
<td>cxt.strokeStyle="blue";</td>
</tr>
<tr>
<td></td>
<td>cxt.arc(0,-125,6,0,360,false);</td>
</tr>
<tr>
<td></td>
<td>cxt.stroke();</td>
</tr>
<tr>
<td></td>
<td>cxt.fillStyle="gray";</td>
</tr>
<tr>
<td></td>
<td>cxt.fill();</td>
</tr>
<tr>
<td></td>
<td>cxt.closePath();</td>
</tr>
<tr>
<td></td>
<td>cxt.restore();</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>cxt.beginPath();</td>
</tr>
<tr>
<td></td>
<td>cxt.save();</td>
</tr>
<tr>
<td></td>
<td>cxt.translate(250,250);</td>
</tr>
<tr>
<td></td>
<td>cxt.arc(0,0,6,0,360,false);</td>
</tr>
<tr>
<td></td>
<td>cxt.stroke();</td>
</tr>
<tr>
<td></td>
<td>cxt.fillStyle="gray";</td>
</tr>
<tr>
<td></td>
<td>cxt.fill();</td>
</tr>
<tr>
<td></td>
<td>cxt.restore();</td>
</tr>
<tr>
<td></td>
<td>cxt.closePath();</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>var year=now.getFullYear();</td>
</tr>
<tr>
<td></td>
<td>var month=now.getMonth();</td>
</tr>
<tr>
<td></td>
<td>var day=now.getDate();</td>
</tr>
<tr>
<td></td>
<td>cxt.save();</td>
</tr>
<tr>
<td></td>
<td>cxt.beginPath();</td>
</tr>
<tr>
<td></td>
<td>cxt.translate(250,250);</td>
</tr>
<tr>
<td></td>
<td>cxt.font="20px 宋体";</td>
</tr>
<tr>
<td></td>
<td>cxt.fillText("今天是"+year+"年"+month+"月"+day+"日",-100,120);</td>
</tr>
<tr>
<td></td>
<td>cxt.restore();</td>
</tr>
<tr>
<td></td>
<td>cxt.closePath();</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>}</td>
</tr>
<tr>
<td></td>
<td>drawClock();</td>
</tr>
<tr>
<td></td>
<td>setInterval(drawClock,1000);</td>
</tr>
</tbody>
</table>
</div>
</div>

	</article>



	<article class="post">

		
			<h1><a href="/2016/11/14/CentOS%E4%B8%8B%E6%90%AD%E5%BB%BALAMP/">CentOS下搭建LAMP</a></h1>
		

		<div class="post-content"><h2>1、下载CentOS镜像</h2>
<p>打开网站www.centos.org 下载CentOS 6.5版镜像（即CentOS-6.5-1406-x86_64-DVD.iso），用软碟通软件刻录成系统安装光盘。</p>
<h2>2、安装CentOS</h2>
<p>光盘放入服务器光驱，打开电源，服务器从光驱启动，按提示步骤安装CentOS系统。</p>
<h2>3、安装apache</h2>
<p>登录系统，打开终端，通过su命令切换到root用户（在centos下默认只有root用户有权限安装软件）输入yum install httpd等命令执行完毕，apache安装成功，可通过命令service httpd restart重启apache服务，在浏览器输入localhost可访问测试页面</p>
<h2>4、安装mysql</h2>
<p>进入网站www.mysql.org，下载MySQL-5.6.19-1.linux_glibc2.5.x86_64.rpm-bundle.tar，将文件解压到桌面，使用cd命令切换工作目录到安装包所在的目录，使用命令rpm –ivh * --force，等待7个文件安装完成，使用service mysql start启动mysql服务。在终端输入mysql 发现需要输入密码，但是安装过程中未提示设置密码，这是我们需要通过其他方式找回mysql的root密码</p>
<pre>找回mysql密码方法：修改改MySQL配置文件：vi /etc/my.cnf</pre>
<pre>在[mysqld]的段中加上一句：skip-grant-tables</pre>
<pre>例如：</pre>
<pre>[mysqld]</pre>
<pre>datadir=/var/lib/mysql</pre>
<pre>socket=/var/lib/mysql/mysql.sock</pre>
<pre>skip-name-resolve</pre>
<pre>skip-grant-tables</pre>
<pre>保存并且退出vi。</pre>
<pre>重新启动mysql，使用命令：service mysql restart。</pre>
<pre>再输入mysql，发现已经进入mysql了，这时候就可以修改root用户密码了。</pre>
<pre>输入：use mysql；</pre>
<pre>再输入：UPDATE user SET Password = password ( ‘new-password’ ) WHERE User = ‘root’ ;</pre>
<pre>再输入：flush privileges ;</pre>
<pre>Exit离开数据库，然后将上面修改的mysql配置文件还原。使用service mysql restart重启数据库，使用mysql –u root –p 提示输入密码，此时输入上面设置的密码，即可进入数据库。</pre>
<h2>5、安装php</h2>
<pre>打开终端，su命令，切换到root用户。使用命令yum install php.等待命令执行完毕，php安装成功。使用service httpd restart 命令重启apache服务器 是php生效。</pre>
<pre>到此CentOS下LAMP搭建完成。</pre>
</div>

	</article>



	<article class="post">

		
			<h1><a href="/2016/11/14/C-%E8%B0%83%E7%94%A8%E7%BD%91%E7%BB%9Cweb-service%E8%8E%B7%E5%8F%96%E5%A4%A9%E6%B0%94/">C# 调用网络web service获取天气</a></h1>
		

		<div class="post-content"><div>天气web service 接口地址：http://webservice.webxml.com.cn/WebServices/WeatherWS.asmx</div>
<div><a href="http://photo.blog.sina.com.cn/showpic.html#blogid=8265bd790102v1q5&amp;url=http://album.sina.com.cn/pic/002o3oc9gy6MdOBO6HH6d" target="_blank"><img style="margin: 0px; padding: 0px; border: 0px; list-style: none;" title="C# &lt;wbr&gt;调用网络web &lt;wbr&gt;service获取天气" src="http://s14.sinaimg.cn/mw690/002o3oc9gy6MdOBO6HH6d&amp;690" alt="C# &lt;wbr&gt;调用网络web &lt;wbr&gt;service获取天气" width="462" height="504" name="image_operate_4721411307212634" /></a></p>
<p><a href="http://photo.blog.sina.com.cn/showpic.html#blogid=8265bd790102v1q5&amp;url=http://album.sina.com.cn/pic/002o3oc9gy6MdOBRScUa0" target="_blank"><img style="margin: 0px; padding: 0px; border: 0px; list-style: none;" title="C# &lt;wbr&gt;调用网络web &lt;wbr&gt;service获取天气" src="http://s1.sinaimg.cn/mw690/002o3oc9gy6MdOBRScUa0&amp;690" alt="C# &lt;wbr&gt;调用网络web &lt;wbr&gt;service获取天气" width="497" height="377" name="image_operate_61521411307212998" /></a></p>
</div>
<div>代码：</div>
<div>using System;</div>
<div>using System.Collections.Generic;</div>
<div>using System.ComponentModel;</div>
<div>using System.Data;</div>
<div>using System.Drawing;</div>
<div>using System.Linq;</div>
<div>using System.Text;</div>
<div>using System.Windows.Forms;</div>
<div></div>
<div>namespace WindowsFormsApplication1<wbr /></div>
<div>{</div>
<div> <wbr />  <wbr /> public partial class Form1 : Form</div>
<div> <wbr />  <wbr /> {</div>
<div> <wbr />  <wbr />  <wbr />  <wbr /> public Form1()</div>
<div> <wbr />  <wbr />  <wbr />  <wbr /> {</div>
<div> <wbr />  <wbr />  <wbr />  <wbr />  <wbr />  <wbr /> InitializeComponent();</div>
<div> <wbr />  <wbr />  <wbr />  <wbr /> }</div>
<div></div>
<div> <wbr />  <wbr />  <wbr />  <wbr /> private void button1_Click(object sender, EventArgs e)</div>
<div> <wbr />  <wbr />  <wbr />  <wbr /> {</div>
<div></div>
<div> <wbr />  <wbr />  <wbr />  <wbr />  <wbr />  <wbr /> Weather.WeatherWebServiceSoapCli<wbr />ent w = new Weather.WeatherWebServiceSoapCli<wbr />ent("WeatherWebServiceSoap");</div>
<div> <wbr />  <wbr />  <wbr />  <wbr />  <wbr />  <wbr /> string[] s = new string[32];</div>
<div> <wbr />  <wbr />  <wbr />  <wbr />  <wbr />  <wbr /> s = w.getWeatherbyCityName(textBox1.Text);</div>
<div> <wbr />  <wbr />  <wbr />  <wbr />  <wbr />  <wbr /> if (s[8] == "")</div>
<div> <wbr />  <wbr />  <wbr />  <wbr />  <wbr />  <wbr /> {</div>
<div> <wbr />  <wbr />  <wbr />  <wbr />  <wbr />  <wbr />  <wbr />  <wbr /> MessageBox.Show("暂时不支持您查询的城市");</div>
<div> <wbr />  <wbr />  <wbr />  <wbr />  <wbr />  <wbr /> }</div>
<div> <wbr />  <wbr />  <wbr />  <wbr />  <wbr />  <wbr /> else</div>
<div> <wbr />  <wbr />  <wbr />  <wbr />  <wbr />  <wbr /> {</div>
<div> <wbr />  <wbr />  <wbr />  <wbr />  <wbr />  <wbr />  <wbr />  <wbr /> richTextBox1.Text="";</div>
<div> <wbr />  <wbr />  <wbr />  <wbr />  <wbr />  <wbr />  <wbr />  <wbr /> for (int i = 0; i &lt;= 22; i++)</div>
<div> <wbr />  <wbr />  <wbr />  <wbr />  <wbr />  <wbr />  <wbr />  <wbr /> {</div>
<div> <wbr />  <wbr />  <wbr />  <wbr />  <wbr />  <wbr />  <wbr />  <wbr />  <wbr />  <wbr /> richTextBox1.Text += s[i];</div>
<div></div>
<div> <wbr />  <wbr />  <wbr />  <wbr />  <wbr />  <wbr />  <wbr />  <wbr /> }</div>
<div></div>
<div> <wbr />  <wbr />  <wbr />  <wbr />  <wbr />  <wbr /> }</div>
<div> <wbr />  <wbr />  <wbr />  <wbr /> }</div>
<div> <wbr />  <wbr /> }</div>
<div>}</div>
</div>

	</article>






	<div class="postnavigation">

		
			
				<a class="prev left" href="/">&larr; Newer</a>
			
		

		<span class="pages">Page 2 of 6</span>

		
			<a class="next right" href="/page3/">Older &rarr;</a>
		

	</div>

    </div>



  </div>



  <footer id="footer">
    <p class="copyright">Copyright &copy; 2017 Solar Theme. Powered by <a href="http://jekyllrb.com">Jekyll</a>, theme by <a href="http://www.webmaster-source.com">Matt Harzewski</a></p>
  </footer>



  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.10.1/jquery.min.js"></script>
  <script src="/assets/js/jquery.mobilemenu.min.js"></script>

  <script>
    $(document).ready(function(){
      $('#sidebar nav ul').mobileMenu({'topOptionText': 'Menu', 'prependTo': '#sidebar nav'});
    });
  </script>



</body>
</html>