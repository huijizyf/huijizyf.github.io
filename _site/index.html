<!DOCTYPE html>
<html>
<head>

  <meta charset="UTF-8">
  <title>Solar Theme</title>
  <meta name="viewport" content="width=device-width">

  <!--[if lt IE 9]>
    <script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="/assets/css/style.css" rel="stylesheet" />
  <link href="/assets/css/colors-dark.css" rel="stylesheet" />

</head>

<body>



  <header id="header">
    <h1><a href="/"><i class="icon-sun"></i> Solar Theme</a></h1>
    <p>A stylish blog using the Solarized color palette</p>
  </header>



  <div id="page">



    <div id="sidebar">
      <nav>
        <ul>
          <li><a href="/">Home</a></li>
          <li><a href="/archives">Archive</a></li>
          <li><a href="/about">About</a></li>
          <li><a href="http://twitter.com/redwall_hp">Twitter</a></li>
          <li><a href="/feed.xml">RSS Feed</a></li>
        </ul>
      </nav>
    </div>



    <div id="content">
      

	<article class="post">

		
			<h1><a href="/2017/07/19/%E7%A7%BB%E6%A4%8Dwifidog%E8%87%B3android5.1%E5%B9%B3%E5%8F%B0/">移植wifidog至android5.1平台</a></h1>
		

		<div class="post-content"><h2 id="toc_0">移植wifidog至android5.1平台</h2>
<h3 id="toc_1">实现的功能</h3>
<p>先使用nanohttpd在安卓内实现http server的功能，然后在已经移植并开启wifidog的安卓平台开启热点，当其它的手机连接到此热点时，手机上会弹出我们在手机上搭建的http server中运行的指定的网页。如果我们的安卓平台是有多网卡的话，我们也能指定手机连接到此热点时打开外部其他网站的网页。因为是单网卡的设备即时指定了外部的网页，手机连接到此热点因为未连接到互联网，也无法打开外部的网页。</p>
<h3 id="toc_2">所需内容</h3>
<p>1.NanoHttpd是一个安卓平台的Http Server，具体可看github上的介绍，本文主要说wifidog在安卓平台的编译，对NanoHttpd的使用不做介绍。</p>
<p>2.wifidog源码。</p>
<div>
<pre><code class="language-none">来自github的简介：The WiFi Guard Dog project is a complete and 
embeddable captive portal solution for wireless community groups 
or individuals who wish to open a free hotspot while still 
preventing abuse of their Internet connection.</code></pre>
</div>
<p>3.移植目标的安卓平台源码。本文针对的目标平台是基于三星4418平台的安卓开发板。</p>
<p>以上列表中所需的1，2两项的源码链接地址如下：</p>
<p>-<a href="https://github.com/NanoHttpd/nanohttpd">NanoHttpd</a></p>
<p>-<a href="https://github.com/wifidog/wifidog-gateway">wifidog</a></p>
<h3 id="toc_3">移植步骤</h3>
<p>1.使用NanoHttpd在安卓平台搭建HttpServer（编写apk程序即可，具体步骤可见NanoHttpd 在github上的介绍）</p>
<p>2.在安卓平台的源码<strong>external</strong>目录下新建文件夹命名为<strong>wifidog</strong>，</p>
<p>3.下载wifidog源码，并将下载到的源码放入第2步中新建的<strong>wifidog</strong>文件夹中</p>
<p>4.在wifidog目录下新建<strong>config.h</strong>文件，在文件中写入以下代码：</p>
<div>
<pre><code class="language-none"> #define VERSION "v1.0"
 #define HAVE_STDARG_H
 #define __ANDROID__</code></pre>
</div>
<p>5.在wifidog目录下新建Android.mk文件，在文件中写入以下内容：</p>
<div>
<pre><code class="language-none">LOCAL_PATH := $(call my-dir)
include $(CLEAR_VARS)

LOCAL_MODULE := wifidog
LOCAL_C_INCLUDES=$(LOCAL_PATH)/libhttpd 
LOCAL_SRC_FILES = src/gateway.c \
        src/auth.c \
        src/client_list.c \
        src/conf.c \
        src/firewall.c \
        src/http.c \
        src/safe.c \
        src/centralserver.c \
        src/commandline.c \
        src/debug.c \
        src/fw_iptables.c \
        src/httpd_thread.c \
        src/ping_thread.c \
        src/util.c \
        src/wdctl_thread.c \
        src/simple_http.c \
        src/pstring.c \
        src/wd_util.c \
        src/main.c \
        ./libhttpd/api.c \
        ./libhttpd/ip_acl.c \
        ./libhttpd/protocol.c \
        ./libhttpd/version.c
LOCAL_SHARED_LIBRARIES = $(SHARED_LIBRARIES)
include $(BUILD_EXECUTABLE)
</code></pre>
</div>
<p>以上步骤完成了对代码的准备，此时进入wifidog目录下使用mm命令已经可以编译通过了，但是还没有完成对wifidog的配置，接下来的我们需要修改配置文件和增加启动脚本。</p>
<p>6.在wifidog目录下找到<strong>wifidog.conf</strong>配置文件，修改此文件内容：</p>
<div>
<pre><code class="language-none">ExternalInterface lo    #如果双网卡设备此处可设定为开启wifi热点网卡的另外一块网卡，因为我们的开发板为单网卡，此处指定了回环

GatewayInterface wlan0   #指定我们开启了热点的网卡设备名称

AuthServer {
    Hostname 192.168.43.1           #http server 地址
    HTTPPort 8080                   #http server端口
    SSLAvailable no                 #https是否可用
    Path /                          #http页面路径  
    LoginScriptPathFragment         /
    PortalScriptPathFragment /
    MsgScriptPathFragment /
    PingScriptPathFragment /
    AuthScriptPathFragment /

}

以上未注释的配置项的意思在下发完整的配置文件中有解释
</code></pre>
</div>
<p>修改完成后的配置文件内容如下：</p>
<div>
<pre><code class="language-none"># $Id$
# WiFiDog Configuration file

# Parameter: GatewayID
# Default: default
# Optional
#
# Set this to the node ID on the auth server
# This is used to give a customized login page to the clients and for
# monitoring/statistics purpose. If you run multiple gateways on the same
# machine each gateway needs to have a different gateway id.
# If none is supplied, the mac address of the GatewayInterface interface will be used,
# without the : separators

# GatewayID default

# Parameter: ExternalInterface
# Default: NONE
# Optional
#
# Set this to the external interface (the one going out to the Inernet or your larger LAN).  
# Typically vlan1 for OpenWrt, and eth0 or ppp0 otherwise,
# Normally autodetected

ExternalInterface lo

# Parameter: GatewayInterface
# Default: NONE
# Mandatory
#
# Set this to the internal interface (typically your wifi interface).    
# Typically br-lan for Openwrt (by default the wifi interface is bridged with wired lan in openwrt)
# and eth1, wlan0, ath0, etc. otherwise
# You can get this interface with the ifconfig command and finding your wifi interface

GatewayInterface wlan0

# Parameter: GatewayAddress
# Default: Find it from GatewayInterface
# Optional
#
# Set this to the internal IP address of the gateway.  Not normally required.

# GatewayAddress 192.168.43.1

# Parameter: HtmlMessageFile
# Default: wifidog-msg.html
# Optional
#
# This allows you to specify a custome HTML file which will be used for
# system errors by the gateway. Any $title, $message and $node variables
# used inside the file will be replaced.
#
# HtmlMessageFile /opt/wifidog/etc/wifidog-.html

# Parameter: AuthServer
# Default: NONE
# Mandatory, repeatable
#
# This allows you to configure your auth server(s).  Each one will be tried in order, untill one responds.
# Set this to the hostname or IP of your auth server(s), the path where
# WiFiDog-auth resides in and the port it listens on.
#AuthServer {
#   Hostname                 (Mandatory; Default: NONE)
#   SSLAvailable             (Optional; Default: no; Possible values: yes, no)
#   SSLPort                  (Optional; Default: 443)
#   HTTPPort                 (Optional; Default: 80)
#   Path                     (Optional; Default: /wifidog/ Note:  The path must be both prefixed and suffixed by /.  Use a single / for server root.)
#   LoginScriptPathFragment  (Optional; Default: login/? Note:  This is the script the user will be sent to for login.)
#   PortalScriptPathFragment (Optional; Default: portal/? Note:  This is the script the user will be sent to after a successfull login.)
#   MsgScriptPathFragment    (Optional; Default: gw_message.php? Note:  This is the script the user will be sent to upon error to read a readable message.)
#   PingScriptPathFragment    (Optional; Default: ping/? Note:  This is the wifidog-ping protocol. See http://dev.wifidog.org/wiki/doc/developer/WiFiDogProtocol_V1)
#   AuthScriptPathFragment    (Optional; Default: auth/? Note:  This is the wifidog-auth protocol. See http://dev.wifidog.org/wiki/doc/developer/WiFiDogProtocol_V1)
#}
# If SSLAvailable is set, then the client will be redirected to the
# auth daemon on its HTTPS port. If Wifidog is compiled with SSL support,
# then Wifidog will also use HTTPS to talk to the auth server instead of
# plain HTTP.
#

AuthServer {
    Hostname 192.168.43.1
    HTTPPort 8080
    SSLAvailable no
    Path /
    LoginScriptPathFragment         /
    PortalScriptPathFragment /
    MsgScriptPathFragment /
    PingScriptPathFragment /
    AuthScriptPathFragment /

}

#AuthServer {
#    Hostname auth2.ilesansfil.org
#    SSLAvailable yes
#    Path /
#}

# Parameter: DeltaTraffic
# Default: no
# Optional
#
# Set this to true if you want to reset each user's traffic (Outgoing and Incoming) value after each Auth operation.
# If this is enabled, Wifidog will add two new parameters to the AuthScriptPathFragment: Incoming_Delta, Outgoing_delta. 
# DeltaTraffic no

# Parameter: Daemon
# Default: 1
# Optional
#
# Set this to true if you want to run as a daemon
# Daemon 1

# Parameter: GatewayPort
# Default: 2060
# Optional
#
# Listen on this port
# GatewayPort 2060

# Parameter: ProxyPort
# Default: 0 (disable)
# Optional
#
# Redirect http traffic of knowns &amp; probations users
# to a local transparent proxy listening on ProxyPort port
# ProxyPort 0

# Parameter: HTTPDName
# Default: WiFiDog
# Optional
#
# Define what name the HTTPD server will respond
# HTTPDName WiFiDog

# Parameter: HTTPDMaxConn
# Default: 10
# Optional
#
# How many sockets to listen to
# HTTPDMaxConn 10

# Parameter: HTTPDRealm
# Default: WiFiDog
# Optional
#
# The name of the HTTP authentication realm. This only used when a user
# tries to access a protected WiFiDog internal page. See HTTPUserName.
# HTTPDRealm WiFiDog

# Parameter: HTTPDUserName / HTTPDPassword
# Default: unset
# Optional
#
# The gateway exposes some information such as the status page through its web
# interface. This information can be protected with a username and password,
# which can be set through the HTTPDUserName and HTTPDPassword parameters.
# HTTPDUserName admin
# HTTPDPassword secret

# Parameter: CheckInterval
# Default: 60
# Optional
#
# How many seconds should we wait between timeout checks.  This is also
# how often the gateway will ping the auth server and how often it will
# update the traffic counters on the auth server.  Setting this too low
# wastes bandwidth, setting this too high will cause the gateway to take 
# a long time to switch to it's backup auth server(s).

# CheckInterval 60

# Parameter: ClientTimeout
# Default: 5
# Optional
#
# Set this to the desired of number of CheckInterval of inactivity before a client is logged out
# The timeout will be INTERVAL * TIMEOUT
ClientTimeout 5

# Parameter: SSLPeerVerification
# Default: yes
# Optional
#
# Enable peer certificate verification when talking to the auth
# server over SSL/TLS. Disabling this setting is mainly useful if
# you do not want  to install ca-certificates.
#
# If this setting is set to yes, then the certificates in
# the directory indicated by SSLCertPath will be used to
# verify the auth server.
#
# This setting requires that WifiDog is compiled with SSL support.
# It will be ignored otherwise.
#
# To disable SSL completely for testing purposes, set SSLAvailable
# to False for the auth server in question. Note that this will disable
# HTTPS when redirecting clients to your auth server.
#
# SSLPeerVerification yes

# Parameter: SSLCertPath
# Default: /etc/ssl/certs/
# Optional
#
# Where to look for SSL certificates to verify the auth servers
# certificate. Note that these will only be used if the auth server
# in question is configured with SSLAvailable yes.
#
# The certificates in this directory must be named by their hash
# value. For OpenWRT, you need a ca-certificates package newer
# than what is shipped in Barrier Breaker (see 
# https://dev.openwrt.org/ticket/16537).
#
# This setting requires that WifiDog is compiled with SSL support.
# It will be ignored otherwise.
#
# SSLCertPath /etc/ssl/certs/ 

# Parameter: SSLAllowedCipherList
# Default: all ciphers supported
# Optional
#
# Which cipher suite to allow. Note that CyaSSL will ignore cipher
# suites that use algorithms that aren't compiled in or cipher
# suites *WITH ERRORS IN THEIR NAMES*.
#
# Please see CyaSSL documentation for allowed values, format is a
# string where the ciphers are separated by colons (:) with no
# spaces. Ciphers are ordered from most desirable to least desirable.
#
# SSLAllowedCipherList ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES128-SHA:ECDHE-ECDSA-AES256-SHA:ECDHE-RSA-AES128-SHA:ECDHE-RSA-AES256-SHA:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384:DHE-RSA-AES128-SHA256:DHE-RSA-AES256-SHA256:ECDH-ECDSA-AES128-GCM-SHA256:ECDH-ECDSA-AES256-GCM-SHA384:ECDH-RSA-AES128-GCM-SHA256:ECDH-RSA-AES256-GCM-SHA384:AES128-GCM-SHA256:AES256-GCM-SHA384:AES128-SHA256:AES256-SHA256:ECDH-ECDSA-AES128-SHA:ECDH-ECDSA-AES256-SHA:ECDH-RSA-AES128-SHA:ECDH-RSA-AES256-SHA:AES128-SHA:AES256-SHA

# Parameter: SSLUseSNI
# Default: no
# Optional
#
# Enable SNI (Server Name Indication) TLS extension.
# Enabling this setting is mainly useful if the auth server is hosted
# multiple secure (HTTPS) websites. The WifiDog should indicate which hostname
# it is attempting to connect to at the start of the handshaking process.
#
# This setting requires that WifiDog is compiled with SSL support.
# It will be ignored otherwise.
#
# SSLUseSNI no

# Parameter: TrustedMACList
# Default: none
# Optional
#

# Check DNS health by querying IPs of these hosts
PopularServers kernel.org,ieee.org

# Comma separated list of MAC addresses who are allowed to pass
# through without authentication.
# N.B.: weak security, since MAC addresses are easy to spoof.
#
#TrustedMACList 00:00:DE:AD:BE:AF,00:00:C0:1D:F0:0D

# Parameter: FirewallRuleSet
# Default: none
# Mandatory
#
# Groups a number of FirewallRule statements together.

# Parameter: FirewallRule
# Default: none
# 
# Define one firewall rule in a rule set.

# Rule Set: global
# 
# Used for rules to be applied to all other rulesets except locked.
FirewallRuleSet global {

    # FirewallRule syntax:
    # FirewallRule (block|drop|allow|log|ulog) [(tcp|udp|icmp) [port X or port-range X:Y]] [to IP/CIDR]

    ## To block SMTP out, as it's a tech support nightmare, and a legal liability
    #FirewallRule block tcp port 25
    
    ## Use the following if you don't want clients to be able to access machines on 
    ## the private LAN that gives internet access to wifidog.  Note that this is not
    ## client isolation;  The laptops will still be able to talk to one another, as
    ## well as to any machine bridged to the wifi of the router.
    # FirewallRule block to 192.168.0.0/16
    # FirewallRule block to 172.16.0.0/12
    # FirewallRule block to 10.0.0.0/8
    
    ## This is an example ruleset for the Teliphone service.
    #FirewallRule allow udp to 69.90.89.192/27
    #FirewallRule allow udp to 69.90.85.0/27
    #FirewallRule allow tcp port 80 to 69.90.89.205

    ## This is an example ruleset for example.com
    ## example.com means example.com and *.example.com
    #FirewallRule allow tcp to example.com

    ## Use the following if you are having problems with Apple iOS 7 clients.
    ## See #7 and #14 at https://github.com/wifidog/wifidog-gateway/issues/
    #FirewallRule allow tcp to apple.com
    #FirewallRule allow tcp to icloud.com

    ## Use the following to log or ulog the traffic you want to allow or block.
    # For OPENWRT: use of these feature requires modules ipt_LOG or ipt_ULOG present in dependencies
    # iptables-mod-extra and iptables-mod-ulog (to adapt it to the linux distribution). 
    # Note: the log or ulog rule must be passed before, the rule you want to match.
    # for openwrt: use of these feature requires modules ipt_LOG or ipt_ULOG present in dependencies
    # iptables-mod-extra and iptables-mod-ulog
    # For example, you want to log (ulog works the same way) the traffic allowed on port 80 to the ip 69.90.89.205:
    #FirewallRule log tcp port 80 to 69.90.89.205
    #FirewallRule allow tcp port 80 to 69.90.89.205
    # And you want to know, who matche your block rule:
    #FirewallRule log to 0.0.0.0/0
    #FirewallRule block to 0.0.0.0/0
}

# Rule Set: validating-users
#
# Used for new users validating their account
FirewallRuleSet validating-users {
    FirewallRule allow to 0.0.0.0/0
}

# Rule Set: known-users
#
# Used for normal validated users.
FirewallRuleSet known-users {
    FirewallRule allow to 0.0.0.0/0
}

# Rule Set: auth-is-down
#
# Does nothing when not configured.
#
# Used when auth server is down
#FirewallRuleSet auth-is-down {
#  FirewallRule allow to 0.0.0.0/0
#}

# Rule Set: unknown-users
#
# Used for unvalidated users, this is the ruleset that gets redirected.
#
# XXX The redirect code adds the Default DROP clause.
FirewallRuleSet unknown-users {
    # Use to-ipset to block or allow externally specified hosts.
    # Ipsets are created with the ipset utility. This is useful to
    # block or allow hosts at runtime externally.
    # For example, if your auth server requires users to log in
    # via Facebook, use the ipset feature built into dnsmasq to
    # to populate a list of various IPs used by the Facebook networks.
    #FirewallRule allow to-ipset fb
    FirewallRule allow udp port 53
    FirewallRule allow tcp port 53
    FirewallRule allow udp port 67
    FirewallRule allow tcp port 67
}

# Rule Set: locked-users
#
# Not currently used
FirewallRuleSet locked-users {
    FirewallRule block to 0.0.0.0/0
}
</code></pre>
</div>
<p>7.在安卓平台源码中增加文件拷贝项，在编译时将此配置文件复制至/system/etc目录中。不同平台路径不完全一样，此处就不写我的路径了，具体方式可参考各平台的说明</p>
<p>8.修改启动脚本，在wifidog目录下找到scripts目录下的init.d文件夹，修改init.d文件夹中的wifidog文件内容</p>
<div>
<pre><code class="language-none">删除第一行的：#!/bin/sh

将以下两行内容修改:
IPT=/usr/sbin/iptables
WD_DIR=/usr/bin

为

IPT=/system/bin/iptables
WD_DIR=/system/bin
</code></pre>
</div>
<p>修改完成后的脚本内容为：</p>
<div>
<pre><code class="language-none">#
# Could be better, but it's working as expected
#
# 
#
# chkconfig: 345 65 35
#
# description: Startup/shutdown script for Wifidog captive portal
# processname: wifidog

# Date    : 2004-08-25
# Version : 1.0

IPT=/system/bin/iptables
WD_DIR=/system/bin
OPTIONS=""

case "$1" in
  start)
    echo "Starting Wifidog ... "
    if $WD_DIR/wdctl status 2&gt; /dev/null
    then
    echo "FAILED:  Wifidog already running"
    else
        $0 test-module
    if $WD_DIR/wifidog $OPTIONS
    then
        echo "OK"
    else
        echo "FAILED:  Wifidog exited with non 0 status"
    fi
    fi
    ;;
  restart)
    $0 stop
    sleep 2
    $0 start
    ;;
  reload)
    $0 stop
    sleep 2
    $0 start
    ;;
  stop)
    echo "Stopping Wifidog ... "
    if $WD_DIR/wdctl status 2&gt; /dev/null
    then
        if $WD_DIR/wdctl stop
    then
        echo "OK"
    else
        echo "FAILED:  wdctl stop exited with non 0 status"
    fi
       
    else
       echo "FAILED:  Wifidog was not running"
    fi
    ;;
  status)
    $WD_DIR/wdctl status
    ;;
  debug|test-module)

    ### Test ipt_mark with iptables
    test_ipt_mark () {
      IPTABLES_OK=$($IPT -A FORWARD -m mark --mark 2 -j ACCEPT 2&gt;&amp;1 | grep "No chain.target.match")
      if [ -z "$IPTABLES_OK" ]; then
        $IPT -D FORWARD -m mark --mark 2 -j ACCEPT 2&gt;&amp;1
        echo 1
      else
        echo 0
      fi
    }
    ### Test ipt_mac with iptables
    test_ipt_mac () {
      IPTABLES_OK=$($IPT -A INPUT -m mac --mac-source 00:00:00:00:00:00 -j ACCEPT 2&gt;&amp;1 | grep "No chain.target.match")
      if [ -z "$IPTABLES_OK" ]; then
        $IPT -D INPUT -m mac --mac-source 00:00:00:00:00:00 -j ACCEPT 2&gt;&amp;1
        echo 1
      else
        echo 0
      fi
    }

    ### Test ipt_REDIRECT with iptables
    test_ipt_REDIRECT () {
      IPTABLES_OK=$($IPT -t nat -A PREROUTING -p tcp --dport 80 -j REDIRECT --to-ports 2060 2&gt;&amp;1 | grep "No chain.target.match")
      if [ -z "$IPTABLES_OK" ]; then
        $IPT -t nat -D PREROUTING -p tcp --dport 80 -j REDIRECT --to-ports 2060 2&gt;&amp;1
        echo 1
      else
        echo 0
      fi
    }

    ### Find a module on disk
    module_exists () {
    echo " Looking for a module on disk"
      EXIST=$(find /lib/modules/`uname -r` -name $1.*o 2&gt;/dev/null)
      if [ -n "$EXIST" ]; then
        echo 1
      else
        echo 0
      fi
    }

    ### Test if a module is in memory
    module_in_memory () {
      MODULE=$(lsmod | grep $1 | awk '{print $1}')
      if [ "$MODULE" = "$1" ]; then
        echo 1
      else
        echo 0
      fi
    }

    echo "Testing for iptables modules"

    echo "  Testing ipt_mac"
    TEST_IPT_MAC=$(test_ipt_mac)
    if [ "$TEST_IPT_MAC" = "0" ]; then
      echo "   iptables is not working with ipt_mac"
      echo "   Scanning disk for ipt_mac module"
      TEST_IPT_MAC_MODULE_EXISTS=$(module_exists "ipt_mac")
      if [ "$TEST_IPT_MAC_MODULE_EXISTS" = "0" ]; then
        echo "   ipt_mac module is missing, please install it (kernel or module)"
        exit
      else
        echo "   ipt_mac module exists, trying to load"
        insmod ipt_mac &gt; /dev/null
        TEST_IPT_MAC_MODULE_MEMORY=$(module_in_memory "ipt_mac")
        if [ "$TEST_IPT_MAC_MODULE_MEMORY" = "0" ]; then
          echo "  Error: ipt_mac not loaded"
          exit
        else
          echo "  ipt_mac loaded sucessfully"
        fi
      fi
    else
      echo "   ipt_mac  module is working"
    fi

    echo "  Testing ipt_mark"
    TEST_IPT_MARK=$(test_ipt_mark)
    if [ "$TEST_IPT_MARK" = "0" ]; then
      echo "   iptables is not working with ipt_mark"
      echo "   Scanning disk for ipt_mark module"
      TEST_IPT_MARK_MODULE_EXISTS=$(module_exists "ipt_mark")
      if [ "$TEST_IPT_MARK_MODULE_EXISTS" = "0" ]; then
        echo "   iptables ipt_mark module missing, please install it (kernel or module)"
        exit
      else
        echo "   ipt_mark module exists, trying to load"
        insmod ipt_mark
        TEST_IPT_MARK_MODULE_MEMORY=$(module_in_memory "ipt_mark")
        if [ "$TEST_IPT_MARK_MODULE_MEMORY" = "0" ]; then
          echo "   Error: ipt_mark not loaded"
          exit
        else
          echo "   ipt_mark loaded sucessfully"
        fi
      fi
      else
    echo "   ipt_mark module is working"
    fi

##TODO:  This will not test if required iptables userspace (iptables-mod-nat on Kamikaze) is installed
    echo "  Testing ipt_REDIRECT"
    TEST_IPT_MAC=$(test_ipt_REDIRECT)
    if [ "$TEST_IPT_MAC" = "0" ]; then
      echo "   iptables is not working with ipt_REDIRECT"
      echo "   Scanning disk for ipt_REDIRECT module"
      TEST_IPT_MAC_MODULE_EXISTS=$(module_exists "ipt_REDIRECT")
      if [ "$TEST_IPT_MAC_MODULE_EXISTS" = "0" ]; then
        echo "   ipt_REDIRECT module is missing, please install it (kernel or module)"
        exit
      else
        echo "   ipt_REDIRECT module exists, trying to load"
        insmod ipt_REDIRECT &gt; /dev/null
        TEST_IPT_MAC_MODULE_MEMORY=$(module_in_memory "ipt_REDIRECT")
        if [ "$TEST_IPT_MAC_MODULE_MEMORY" = "0" ]; then
          echo "  Error: ipt_REDIRECT not loaded"
          exit
        else
          echo "  ipt_REDIRECT loaded sucessfully"
        fi
      fi
    else
      echo "   ipt_REDIRECT  module is working"
    fi

    ;;

  *)
   echo "Usage: $0 {start|stop|restart|reload|status|test-module}"
   exit 1
   ;;
esac
</code></pre>
</div>
<p>9.在安卓平台源码中增加文件拷贝项，在编译时将init.d目录连同底下的wifidog启动脚本复制至/system/etc目录中。不同平台路径不完全一样，此处就不写我的路径了，具体方式可参考各平台的说明</p>
<p>10.增加开机自启动wifidog的功能，修改安卓平台的init脚本 增加以下内容</p>
<div>
<pre><code class="language-none">on post-fs-data节点下增加：
chmod 0777 /etc/init.d/wifidog    #为了给启动脚本增加执行权限

增加服务启动：
service wifiDog /system/etc/init.d/wifidog start
    class late_start
    user root
    group root
    oneshot</code></pre>
</div>
<p>10.移植完成，开始愉快的编译安卓源码吧。</p>
</div>

	</article>



	<article class="post">

		
			<h1><a href="/2017/06/09/%E4%BD%BF%E7%94%A8Python%E7%BC%96%E5%86%99apk%E6%89%B9%E9%87%8F%E5%AE%89%E8%A3%85%E5%B7%A5%E5%85%B7/">使用Python编写apk批量安装工具</a></h1>
		

		<div class="post-content"><h2>git地址：https://github.com/huijizyf/python-apkInstaller.git</h2>
<h2 id="toc_0">背景</h2>
<p>公司项目安卓系统内置应用数量较多，系统编译完成刷入系统时UserData数量太大，导致部分应用未自动安装，因此使用新的安装方式。</p>
<h2 id="toc_1">实现方式</h2>
<p>使用pyhton实现，可在多平台运行，使用tkiner编写图形界面，简单快捷</p>
<h2 id="toc_2">代码</h2>
<div>
<pre><code class="language-none">#-*- coding: UTF-8 -*- 
from Tkinter import *
import os
import commands
import tkMessageBox

class Application(Frame):
    apk_list=list()
    listbox=''
    logbox=''
    def __init__(self, master=None):
        self.init_apk_list()
        Frame.__init__(self, master,height=80,width=80)
        self.listbox  = Listbox(self,width=50,selectmode=MULTIPLE) 
        self.logbox=Listbox(self,width=50,height=20)
        self.pack()
        self.init_ui()

    def init_apk_list(self):
        pathDir =  os.listdir("./apk")
        for sub_file in pathDir:
            print sub_file
            if(sub_file.endswith('.apk')):
                self.apk_list.append(sub_file)
    
    def init_ui(self):
        for apk_name in self.apk_list:
            self.listbox.insert(END,apk_name)
        self.listbox.pack()
        selectAllBtn=Button(self,text="全部选中",command=self.selectAll)
        selectAllBtn.pack()
        install_btn=Button(self,text="开始安装",command=self.start_install_apk)
        install_btn.pack()
        self.logbox.pack()

    def selectAll(self):
        self.listbox.selection_set(0,self.listbox.size())


    def start_install_apk(self):
        successed=0
        failed=0
        selected=self.listbox.curselection()
        self.logbox.insert(END,"准备安装apk")
        self.logbox.insert(END,"共有"+str(self.listbox.size())+"个应用，将有"+str(len(selected))+"个应用被安装")
        self.logbox.insert(END,"")
        self.logbox.insert(END,"--------------------------------------------")
        self.logbox.insert(END,"")
        for index in selected:
            apk=self.apk_list[index]
            self.logbox.insert(END,"准备安装: "+apk)
            (status, output) = commands.getstatusoutput('adb install -r ./apk/'+apk)
            print status,output
            if status==0 and ("Success" in output):
                self.logbox.insert(END,"安装成功: "+apk)
                successed=successed+1
            else:
                self.logbox.insert(END,"安装失败: "+apk)
                self.logbox.insert(END,"失败信息:"+output)
                failed=failed+1
            self.logbox.insert(END,"")
            self.update_idletasks()
        self.logbox.insert(END,"--------------------------------------------")
        self.logbox.insert(END,"应用安装结束！！")
        self.logbox.insert(END,"--------------------------------------------")
        self.logbox.insert(END,"安装成功："+str(successed)+"个,安装失败："+str(failed)+"个，请查看上方日志")
            


app = Application()
app.master.title('APK安装器')
app.mainloop()</code></pre>
</div>
</div>

	</article>



	<article class="post">

		
			<h1><a href="/2017/05/23/%E4%BD%BF%E7%94%A8AZTEC%E5%8E%8B%E7%BC%A9%E5%BF%83%E8%B7%B3%E6%95%B0%E6%8D%AE-%E5%B9%B6%E7%BB%98%E5%9B%BE/">使用AZTEC压缩心跳数据，并绘图</a></h1>
		

		<div class="post-content"><h2><img class="alignnone size-full wp-image-255" src="http://donute.com/wp-content/uploads/2017/05/device-2017-05-23-085449.png" alt="device-2017-05-23-085449" width="720" height="1280" /></h2>
<h2 id="toc_0">什么是AZTEC</h2>
<div>
<pre><code class="language-none">AZTEC把原始ECG数据处理成短的直线和斜线。AZTEC算法可以由水平线产生，斜线产生，用抛物线拟合的曲线平滑化几个部分组成。

压缩
1，初始化：
    一个阈值。  数据波动超过这个值得直线认为结束，进入斜线模式
    一个长度限制，  长度超过这个值的线，认为结束，重新计算
    一个最短判断限制，  长度小于这个值的最大值，最小值相差，大于阈值，认为是斜线
2，直线计算
    1，获取第一个点的高程，
    2，在往后加入的点的高程中计算出MAX 和MIN
    3，判断当前点的高程和MAX或者MIN的差是否大于阈值
    4，结束直线计算
    5，存储格式为，T，V   （T是一个正数，表示这段线有多长，V是一个值，表示这段线的高程是多少）
3，斜线计算
    1，获取第一个点的高程
    2，判断接下来小于 长度限制LEN的点的MAX和MIN相差是否大于阈值，
    3，大于阈值判断为斜线，不大于判断为直线
    4，判断当前点V0 的高程和前一个点的相差是否小于规定值，认为斜线结束
    ps，这样的好处是不用判断是正斜线，还是反斜线，
    5，存储格式为 -T ,V
    
解压缩
1，初始化当前高程是 0
2，读取一个点的数据，取得高程V
3，平均划分到每个点的值，即 V/T 是每个点的高程，余数加到最后一个点上
4，读取下一个点的数据，取得其高程V ， 
5，画每个点的公式是  h= ((V-V0)/T)*i    i == T -1 ? h + (V-V0)%T : h
6，i是当前点的下标，根据T 从0开始，V是当前点的高程，V0是前一个点的高程</code></pre>
</div>
<h2 id="toc_1">JAVA从文件中读取并数据解压代码</h2>
<div>
<pre><code class="language-none">public class DecodeFileUtil {
    private String fileName;

    public DecodeFileUtil(String fileName) {
        this.fileName = fileName;
    }

    public List&lt;Float&gt; read() {
        List&lt;Float&gt; decodePoints = new ArrayList&lt;&gt;();
        List&lt;Map&lt;Integer, Integer&gt;&gt; points = new ArrayList&lt;&gt;();

        List&lt;Integer&gt; first = new ArrayList&lt;&gt;();
        List&lt;Integer&gt; second = new ArrayList&lt;&gt;();
        File file = new File(fileName);
        try {
            FileReader reader = new FileReader(file);
            BufferedReader bReader = new BufferedReader(reader);
            String s;
            int i = 0;
            while ((s = bReader.readLine()) != null) {
                if (i % 2 == 0) {
                    first.add((int) Float.parseFloat(s));
                } else {
                    second.add((int) (Float.parseFloat(s)*1000));
                }
                i++;
            }
            for (int j = 0; j &lt; first.size(); j++) {
                Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();
                map.put(first.get(j), second.get(j));
                points.add(map);
            }
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }
        for (Map&lt;Integer, Integer&gt; map : points) {
            int index = points.indexOf(map);
            Map&lt;Integer, Integer&gt; lastMap;
            int lastKey = 0;
            int lastValue = 0;
            if (index &gt; 0) {
                lastMap = points.get(index - 1);
                lastKey = (int) lastMap.keySet().toArray()[0];
                lastValue = lastMap.get(lastKey);
            }
            int key = (int) map.keySet().toArray()[0];
            int value = map.get(key);
            if (key &gt; 0) {
                for (int i = 0; i &lt; key; i++) {
                    decodePoints.add(value / 1000f);
                }
            } else if (key &lt; 0) {
                key=Math.abs(key);
                int average ;
                int remainder ;

                int result = value - lastValue;
                average = result / key;
                remainder = result % key;
                for (int i = 0; i &lt; key; i++) {
                    if (i != key - 1) {
                        decodePoints.add((lastKey + (i + 1) * average) / 1000f);
                    } else {
                        decodePoints.add((lastKey + (i + 1) * average + remainder) / 1000f);
                    }
                }
            }
        }
        return decodePoints;
    }
}</code></pre>
</div>
</div>

	</article>



	<article class="post">

		
			<h1><a href="/2017/01/17/AndroidThings%E5%88%9D%E6%8E%A2/">AndroidThings初探</a></h1>
		

		<div class="post-content"><h2>AndroidThings</h2>
<p>搭梯子访问：https://developer.android.com/things/index.html</p>
<p>为了抢攻智能家电市场，Google 14 日推出全新物联网平台“Android Things”的开发者预<br />
览版本。未来不只是手机，Android 可能将透过喇叭、监视器和路由器等家电，占据家中每个<br />
角落。<br />
可用于打印机、门锁、烤箱、灯泡、插座等<br />
Android Things 的前身为在 2015 年 5 月发布的物联网平台 Brillo，不过至今并未受<br />
到开发者大量采用。Google 强调，新推出的 Android Things 除了承袭 Brillo 的功<br />
能，还加入 Android 开发者熟悉的工具，包含 Android Studio、Android SDK、<br />
Google Play 服务和 Google 云端平台，提供整套打造 Android 智能联网设备所需工具，<br />
让任何 Android 开发者都能轻松打造物联网服务。<br />
只要你有能力打造出 App，你就能打造出一个设备。──Google</p>
<h2>硬件</h2>
<p><img class="alignnone size-full wp-image-233" src="http://donute.com/wp-content/uploads/2017/01/20161229102102_407.jpg" alt="20161229102102_407" width="1280" height="708" /></p>
<p>现在支持以下3款硬件：</p>
<p>1）Intel Edison<br />
2）NXP Pico<br />
3）Raspberry Pi 3<br />
我使用的是树莓派3，拿到板子首先需要在安卓开发者网站下载预览版镜像。地址为：https://developer.android.com/things/preview/download.html<br />
接下来将8G内存以上的高速TF卡放入读卡器，插入电脑，我使用的是OS X系统，给树莓派刷入<br />
系统的步骤与Linux类似使用终端运行以下命令：<br />
dd bs=4m if=iot<em>rpi3.img of=/dev/disk2<br />
其中iot</em>rpi3.img 表示系统镜像所在的目录，我的就在当前目录所以就直接写文件名就OK<br />
接着/dev/disk2是TF在文件系统上的位置。<br />
稍等5分钟左右，系统写入完成，拔下读卡器，将TF卡放入树莓派上电开机。</p>
<h2>第一印象</h2>
<p><img class="alignnone size-full wp-image-235" src="http://donute.com/wp-content/uploads/2017/01/WechatIMG24.jpeg" alt="WechatIMG24" width="1280" height="960" /><br />
接入显示器开机,开机画面后并没有看到我们熟悉的安卓系统界面。而是在一个AndroidThings<br />
的背景图后显示了已经获取的IP地址。对于AndroidThings来说显示屏不是必须的，无显示器<br />
一样可以工作，使用鼠标试用了一下，界面不是很流畅。<br />
值得一提的是系统开机后虽然并没有可供操作的选项，但是当你编写的带UI的程序运行到系统后<br />
是有界面的，与普通app运行基本没有差别。</p>
<h2>使用IIC驱动12864OLED屏幕</h2>
<p><img class="alignnone size-full wp-image-236" src="http://donute.com/wp-content/uploads/2017/01/WechatIMG25.jpeg" alt="WechatIMG25" width="720" height="1280" /><br />
拿到板子不久又购买了一块12864的OLED屏幕和一个DHT11温湿度传感器，然后对OLED屏幕开<br />
始折腾。<br />
要操作点阵显示屏，也就是写数据和写命令！让屏幕休眠、让屏幕滚动之类的操作，就要向屏幕<br />
写命令；要让屏幕显示内容，就要写数据。 怎样让屏幕知道你发送的东西是数据还是命令？有<br />
的屏幕有类似D/C(Data/Command)这样的引脚，说明是通过高低电平来区分，有的屏幕是向屏<br />
幕写入特定的值来区分。 点阵屏内部都有一个驱动芯片，这个驱动芯片就负责按照程序的要<br />
求，在某一个点来进行操作。所谓的初始化就是这个驱动芯片的初始化，初始化中注意两个地<br />
方：<br />
一个是复位！这个非常重要，如果没有完全复位，可能导致屏幕不稳定、显示乱码等畸形问题！<br />
另一个就是初始化代码！这个初始化代码一般都是一些16进制数，可以在显示屏的规格书之类的文档里面找到，可以通过“写命令”的方式能够把初始化代码发送给显示屏。<br />
完成了这些步骤，就可以让它显示你想要的东西了！</p>
<h2>上代码</h2>
<p>//以下代码中不包括字码，因为我的屏幕本身不带字库，所以需要用软件提码得到，具体购买屏幕时一般会附带提码软件</p>
<pre class="pure-highlightjs"><code class="">package com.donute.iot_android.utils;

import com.google.android.things.pio.I2cDevice;

import java.io.IOException;

/**
 * Created by zhouyufei on 2017/1/16.
 */

public class OledUtil {
    private I2cDevice device;
    private static final int Brightness=0xCF;

    public OledUtil(I2cDevice device) {
        this.device = device;
        initOled();
        clearScreen();
    }
    public void initOled(){
        oledCmd((byte)0xae);//--turn off oled panel
        oledCmd((byte)0x00);//---set low column address
        oledCmd((byte)0x10);//---set high column address
        oledCmd((byte)0x40);//--set start line address  Set Mapping RAM Display Start Line ((byte)0x00~(byte)0x3F)
        oledCmd((byte)0x81);//--set contrast control register
        oledCmd((byte) Brightness); // Set SEG Output Current Brightness
        oledCmd((byte)0xa1);//--Set SEG/Column Mapping     (byte)0xa0×óÓÒ·´ÖÃ (byte)0xa1Õý³£
        oledCmd((byte)0xc8);//Set COM/Row Scan Direction   (byte)0xc0ÉÏÏÂ·´ÖÃ (byte)0xc8Õý³£
        oledCmd((byte)0xa6);//--set normal display
        oledCmd((byte)0xa8);//--set multiplex ratio(1 to 64)
        oledCmd((byte)0x3f);//--1/64 duty
        oledCmd((byte)0xd3);//-set display offset   Shift Mapping RAM Counter ((byte)0x00~(byte)0x3F)
        oledCmd((byte)0x00);//-not offset
        oledCmd((byte)0xd5);//--set display clock divide ratio/oscillator frequency
        oledCmd((byte)0x80);//--set divide ratio, Set Clock as 100 Frames/Sec
        oledCmd((byte)0xd9);//--set pre-charge period
        oledCmd((byte)0xf1);//Set Pre-Charge as 15 Clocks &amp; Discharge as 1 Clock
        oledCmd((byte)0xda);//--set com pins hardware configuration
        oledCmd((byte)0x12);
        oledCmd((byte)0xdb);//--set vcomh
        oledCmd((byte)0x40);//Set VCOM Deselect Level
        oledCmd((byte)0x20);//-Set Page Addressing Mode ((byte)0x00/(byte)0x01/(byte)0x02)
        oledCmd((byte)0x02);//
        oledCmd((byte)0x8d);//--set Charge Pump enable/disable
        oledCmd((byte)0x14);//--set((byte)0x10) disable
        oledCmd((byte)0xa4);// Disable Entire Display On ((byte)0xa4/(byte)0xa5)
        oledCmd((byte)0xa6);// Disable Inverse Display On ((byte)0xa6/a7)
        oledCmd((byte)0xaf);//--turn on oled panel
    }
    private void oledCmd(int i) {
        try {
            device.writeRegByte(0x00,(byte)i);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
    public void oledData(int data) {
        try {
            device.writeRegByte(0x40,(byte)(data));
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
    public void oledData(int[] data) {
        try {
            for (int i=0;i&lt;data.length;i++){
                device.writeRegByte(0x40,(byte)(data[i]));
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    /***************功能描述：显示6*8一组标准ASCII字符串  显示的坐标（x,y），y为页范围0～7****************/
    public void oled6x8(int x,int y,char ch[])
    {
        int c=0,i=0,j=0;
        for (int k=0;k&lt;ch.length;k++){
            c =ch[j]-32;
            if(x&gt;126){
                x=0;
                y++;
            }
            OLED_Set_Pos(x,y);
            for(i=0;i&lt;6;i++)
                oledData(CodeTab.F6x8[c][i]);
            x+=6;
            j++;
        }
    }
    /*******************功能描述：显示8*16一组标准ASCII字符串  显示的坐标（x,y），y为页范围0～7****************/
    public void oled8x16(int x,int y,char ch[])
    {
        int c=0,i=0,j=0;
        for (int k=0;k&lt;ch.length;k++){
            c =ch[j]-32;
            if(x&gt;120){
                x=0;
                y++;
            }
            OLED_Set_Pos(x,y);
            for(i=0;i&lt;8;i++)
                oledData(CodeTab.F8X16[c*16+i]);
            OLED_Set_Pos(x,y+1);
            for(i=0;i&lt;8;i++)
                oledData(CodeTab.F8X16[c*16+i+8]);
            x+=8;
            j++;
        }
    }
    /*****************功能描述：显示16*16点阵  显示的坐标（x,y），y为页范围0～7****************************/
    public void oled16x16(int x,int y,int N,int[] codeTab)
    {
        char wm=0;
        int adder=32*N;
        OLED_Set_Pos(x , y);
        for(wm = 0;wm &lt; 16;wm++)
        {
            oledData(codeTab[adder]);
            adder += 1;
        }
        OLED_Set_Pos(x,y + 1);
        for(wm = 0;wm &lt; 16;wm++)
        {
            oledData(codeTab[adder]);
            adder += 1;
        }
    }
    /***********功能描述：显示显示BMP图片128×64起始点坐标(x,y),x的范围0～127，y为页的范围0～7*****************/
    public void drawBmp(int x0,int y0,int x1,int y1,char BMP[])
    {
         int j=0;
         int x,y;
        if(y1%8==0)
            y=y1/8;
        else
            y=y1/8+1;
        for(y=y0;y&lt;y1;y++)
        {
            OLED_Set_Pos(x0,y);
            for(x=x0;x&lt;x1;x++)
            {
                oledData(BMP[j++]);
            }
        }
    }

    /*********************OLED 设置坐标************************************/
    public void OLED_Set_Pos(int x, int y)
    {
        oledCmd(0xb0+y);
        oledCmd(((x&amp;0xf0)&gt;&gt;4)|0x10);
        oledCmd((x&amp;0x0f)|0x01);
    }

    /*****************************清除屏幕显示内容************************************/
    public void clearScreen(){
        int y,x;
        for(y=0;y&lt;8;y++)
        {
            oledCmd((byte) (0xb0+y));
            oledCmd((byte) 0x01);
            oledCmd((byte) 0x10);
            for(x=0;x&lt;128;x++){
                int[] b={0};
                oledData(b);
            }
        }
    }
}
</code></pre>
<p>&nbsp;</p>
<h2>使用GPIO驱动DHT11</h2>
<p><img class="alignnone size-full wp-image-237" src="http://donute.com/wp-content/uploads/2017/01/3339137648818780077.jpg" alt="3339137648818780077" width="750" height="247" /><br />
因为之前有使用GPIO驱动继电器工作的经历，继电器接在3.3V正常工作，接在5V下无法驱动。<br />
在尝试了驱动DHT11的时候很久一直没有成功，起初以为跟最开始驱动继电器的时候一样，电压问题，然后后来仔细核对代码，查看时序图，发现在AndroidThings系统下读取一次GPIO值耗时就在270us左右，而dht11的时序图中电平转换时间都是在100us以下，所以在java下使用GPIO不能捕捉到如此短时间内的电平变化，无法获取到温湿度值。<br />
以下是代码：</p>
<pre class="pure-highlightjs"><code class="">package com.donute.iot_android.utils;


import android.util.Log;

import com.google.android.things.pio.Gpio;

import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

/**
 * Created by zhouyufei on 2017/1/5.
 */

public class TemperatureUtil {
    private Gpio gpio;
    private LoopThread thread;
    private float temp=0.0f;
    private float humi=0.0f;
    private static TemperatureUtil temperatureUtil;

    private TemperatureUtil(Gpio gpio) {
        this.gpio = gpio;
        thread=new LoopThread();
        thread.start();
    }
    public static TemperatureUtil init(Gpio gpio){
        if (temperatureUtil==null){
            temperatureUtil=new TemperatureUtil(gpio);
        }
        return temperatureUtil;
    }
    public void destory(){
        if (thread!=null){
            thread.interrupt();
            thread=null;
        }
    }
    private void calculate(List&lt;Integer&gt; integers){
        Log.d("tem","长度："+integers.size()+"    "+integers+"");
    }
    public float getTemp(){
        return temp;
    }
    public float getHumi(){
        return humi;
    }
    class LoopThread extends Thread{
        @Override
        public void run() {
            super.run();
            while (!isInterrupted()){
                List&lt;Integer&gt; list=new ArrayList&lt;&gt;();
                try {
                    gpio.setDirection(Gpio.DIRECTION_OUT_INITIALLY_HIGH);
                    gpio.setActiveType(Gpio.ACTIVE_HIGH);
                    Thread.sleep(10);
                    gpio.setValue(false);
                    Thread.sleep(2);
                    gpio.setValue(true);
                    gpio.setDirection(Gpio.DIRECTION_IN);
                    gpio.setActiveType(Gpio.ACTIVE_HIGH);
                    while (!gpio.getValue()){
                        Log.d("gpio","low");
                        continue;
                    }
                    while (gpio.getValue()){
                        Log.d("gpio","high");
                        continue;
                    }
                    long l3=System.nanoTime();

                    while (list.size()&lt;40){
                        int j=0;
                        while (!gpio.getValue()){
                            Log.d("gpio","low");
                            continue;
                        }
                        while (gpio.getValue()){
                            Log.d("gpio","high");
                            j=j+1;
                            if (j&gt;100)
                                break;
                        }
                        Log.e("value of j",j+"");
                        if (j&lt;8)
                            list.add(0);
                        else
                            list.add(1);
                    }
                    calculate(list);
                    Thread.sleep(3000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}
</code></pre>
<p>&nbsp;</p>
</div>

	</article>



	<article class="post">

		
			<h1><a href="/2017/01/09/OrangePi%E9%80%9A%E8%BF%87sysfs%E6%8E%A7%E5%88%B6GPIO%E6%8E%A5%E5%8F%A3/">OrangePi通过sysfs控制GPIO接口</a></h1>
		

		<div class="post-content"><p>&nbsp;</p>
<h2 id="toc_0">OrangePi通过sysfs控制GPIO接口</h2>
<h3 id="toc_1">什么是sysfs</h3>
<div>
<pre><code class="language-none">Sysfs 是 Linux 2.6 所提供的一种虚拟文件系统。这个文件系统不仅可以把设备
（devices）和驱动程序(drivers) 的信息从内核输出到 用户空间，也可以用来对设备和驱
动程序做设置。
sysfs 的目的是把一些原本在 procfs 中的，关于设备的部份，独立出来，以‘设备层次结构
架构’（device tree）的形式呈现。这个文件系统由 Patrick Mochel 所写，稍后 
Maneesh Soni 撰写 "sysfs backing store path"，以降低在大型系统中对存储器的需
求量。</code></pre>
</div>
<h3 id="toc_2">使用的硬件</h3>
<div>
<pre><code class="language-none">这里使用的是Orange Pi One，有40Pin的扩展接口，类似树莓派，使用方法也类似。
系统是使用的安卓4.4
导出Gpio接口：
echo XX &gt; /sys/class/gpio/export（其中XX为你要导出的GPIO引脚编号，后面会说到引脚编号计算方法）
如果成功的话，这一步会在/sys/class/gpio目录下生成 /sys/class/gpio/gpioXX
设定IO方向：
echo "out" &gt; /sys/class/gpio/gpioXX/direction（输出）
echo "in" &gt; /sys/class/gpio/gpioXX/direction（输入）

设定输出值：
echo 1 &gt; /sys/class/gpio/gpioXX/value
echo 0 &gt; /sys/class/gpio/gpioXX/value

或者：
echo "high" &gt; /sys/class/gpio/gpioXX/direction（输出，同时置高）
echo "low" &gt; /sys/class/gpio/gpioXX/direction（输出，同时置低）

取消导出：
echo XX &gt; /sys/class/gpio/unexport</code></pre>
</div>
<h3 id="toc_3">引脚映射计算</h3>
<div>
<pre><code class="language-none">Orange Pi One 外设的GPIO如下：
<img class="alignnone size-full wp-image-228" src="http://donute.com/wp-content/uploads/2017/01/20151019002607_51900.jpg" alt="20151019002607_51900" width="2299" height="1139" />
计算公式：

(P后面的字母在字母表中的位置 - 1) * 32 + 后面的数字
例如：
PA0计算得到：0    ------&gt;(1-1)*32+0
PA1计算得到：1       -------&gt;(1-1)*32+1
PA15计算得到：15   -------&gt;(1-1)*32+15
PD14计算得到：110  -------&gt;(4-1)*32+14
PC1计算得到：65   -------&gt;(3-1)*32+1</code></pre>
</div>
<h3 id="toc_4">在Java层控制</h3>
<pre class="pure-highlightjs"><code class="">package com.donute.robot.entities;

import com.donute.robot.utils.ShellUtils;

/**
 * Created by zhouyufei on 2017/1/4.
 */

public class Gpio {
    public static final int HIGH=1;
    public static final int LOW=0;
    public static final String IN="in";
    public static final String OUT="out";
    public static final String DISABLE="disable";
    private String path;
    private String direction=DISABLE;
    private int number;

    public Gpio(int number) {
        this.number = number;
        ShellUtils.execCommand("echo "+number+" &gt; /sys/class/gpio/export",true);
        path="/sys/class/gpio/gpio"+number;
    }
    public Gpio openAsOut(){
        direction=OUT;
        ShellUtils.execCommand("echo "+direction+" &gt; "+path+"/direction",true);
        return this;
    }
    public Gpio openAsIn(){
        direction=IN;
        ShellUtils.execCommand("echo "+direction+" &gt; "+path+"/direction",true);
        return this;
    }
    public Gpio close(){
        direction=DISABLE;
        ShellUtils.execCommand("echo "+number+" &gt; /sys/class/gpio/unexport",true);
        return this;
    }
    public void write(int value){
        ShellUtils.execCommand("echo "+value+" &gt; "+path+"/value",true);
    }
    public int read(){
        ShellUtils.CommandResult result=ShellUtils.execCommand("cat "+path+"/value",true,true);
        if (result.result==0){
            try{
                return Integer.parseInt(result.successMsg);
            }catch (Exception e){
                return -1;
            }
        }else {
            return -1;
        }
    }

    public String getDirection() {
        return direction;
    }

    public int getNumber() {
        return number;
    }

}
</code></pre>
<p>&nbsp;</p>
<h3 id="toc_5">ShellUtil代码</h3>
<pre class="pure-highlightjs"><code class="">package com.donute.robot.utils;

/**
 * Created by zhouyufei on 16/7/31.
 */
import java.io.BufferedReader;
import java.io.DataOutputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.List;

/**
 * ShellUtils
 * &lt;ul&gt;
 * &lt;strong&gt;Check root&lt;/strong&gt;
 * &lt;li&gt;{@link ShellUtils#checkRootPermission()}&lt;/li&gt;
 * &lt;/ul&gt;
 * &lt;ul&gt;
 * &lt;strong&gt;Execte command&lt;/strong&gt;
 * &lt;li&gt;{@link ShellUtils#execCommand(String, boolean)}&lt;/li&gt;
 * &lt;li&gt;{@link ShellUtils#execCommand(String, boolean, boolean)}&lt;/li&gt;
 * &lt;li&gt;{@link ShellUtils#execCommand(List, boolean)}&lt;/li&gt;
 * &lt;li&gt;{@link ShellUtils#execCommand(List, boolean, boolean)}&lt;/li&gt;
 * &lt;li&gt;{@link ShellUtils#execCommand(String[], boolean)}&lt;/li&gt;
 * &lt;li&gt;{@link ShellUtils#execCommand(String[], boolean, boolean)}&lt;/li&gt;
 * &lt;/ul&gt;
 *
 * @author &lt;a href="http://www.trinea.cn" target="_blank"&gt;Trinea&lt;/a&gt; 2013-5-16
 */
public class ShellUtils {

    public static final String COMMAND_SU       = "su";
    public static final String COMMAND_SH       = "sh";
    public static final String COMMAND_EXIT     = "exit\n";
    public static final String COMMAND_LINE_END = "\n";

    private ShellUtils() {
        throw new AssertionError();
    }

    /**
     * check whether has root permission
     *
     * @return
     */
    public static boolean checkRootPermission() {
        return execCommand("echo root", true, false).result == 0;
    }

    /**
     * execute shell command, default return result msg
     *
     * @param command command
     * @param isRoot whether need to run with root
     * @return
     * @see ShellUtils#execCommand(String[], boolean, boolean)
     */
    public static CommandResult execCommand(String command, boolean isRoot) {
        return execCommand(new String[] {command}, isRoot, true);
    }

    /**
     * execute shell commands, default return result msg
     *
     * @param commands command list
     * @param isRoot whether need to run with root
     * @return
     * @see ShellUtils#execCommand(String[], boolean, boolean)
     */
    public static CommandResult execCommand(List&lt;String&gt; commands, boolean isRoot) {
        return execCommand(commands == null ? null : commands.toArray(new String[] {}), isRoot, true);
    }

    /**
     * execute shell commands, default return result msg
     *
     * @param commands command array
     * @param isRoot whether need to run with root
     * @return
     * @see ShellUtils#execCommand(String[], boolean, boolean)
     */
    public static CommandResult execCommand(String[] commands, boolean isRoot) {
        return execCommand(commands, isRoot, true);
    }

    /**
     * execute shell command
     *
     * @param command command
     * @param isRoot whether need to run with root
     * @param isNeedResultMsg whether need result msg
     * @return
     * @see ShellUtils#execCommand(String[], boolean, boolean)
     */
    public static CommandResult execCommand(String command, boolean isRoot, boolean isNeedResultMsg) {
        return execCommand(new String[] {command}, isRoot, isNeedResultMsg);
    }

    /**
     * execute shell commands
     *
     * @param commands command list
     * @param isRoot whether need to run with root
     * @param isNeedResultMsg whether need result msg
     * @return
     * @see ShellUtils#execCommand(String[], boolean, boolean)
     */
    public static CommandResult execCommand(List&lt;String&gt; commands, boolean isRoot, boolean isNeedResultMsg) {
        return execCommand(commands == null ? null : commands.toArray(new String[] {}), isRoot, isNeedResultMsg);
    }

    /**
     * execute shell commands
     *
     * @param commands command array
     * @param isRoot whether need to run with root
     * @param isNeedResultMsg whether need result msg
     * @return &lt;ul&gt;
     *         &lt;li&gt;if isNeedResultMsg is false, {@link CommandResult#successMsg} is null and
     *         {@link CommandResult#errorMsg} is null.&lt;/li&gt;
     *         &lt;li&gt;if {@link CommandResult#result} is -1, there maybe some excepiton.&lt;/li&gt;
     *         &lt;/ul&gt;
     */
    public static CommandResult execCommand(String[] commands, boolean isRoot, boolean isNeedResultMsg) {
        int result = -1;
        if (commands == null || commands.length == 0) {
            return new CommandResult(result, null, null);
        }

        Process process = null;
        BufferedReader successResult = null;
        BufferedReader errorResult = null;
        StringBuilder successMsg = null;
        StringBuilder errorMsg = null;

        DataOutputStream os = null;
        try {
            process = Runtime.getRuntime().exec(isRoot ? COMMAND_SU : COMMAND_SH);
            os = new DataOutputStream(process.getOutputStream());
            for (String command : commands) {
                if (command == null) {
                    continue;
                }

                // donnot use os.writeBytes(commmand), avoid chinese charset error
                os.write(command.getBytes());
                os.writeBytes(COMMAND_LINE_END);
                os.flush();
            }
            os.writeBytes(COMMAND_EXIT);
            os.flush();

            result = process.waitFor();
            // get command result
            if (isNeedResultMsg) {
                successMsg = new StringBuilder();
                errorMsg = new StringBuilder();
                successResult = new BufferedReader(new InputStreamReader(process.getInputStream()));
                errorResult = new BufferedReader(new InputStreamReader(process.getErrorStream()));
                String s;
                while ((s = successResult.readLine()) != null) {
                    successMsg.append(s);
                }
                while ((s = errorResult.readLine()) != null) {
                    errorMsg.append(s);
                }
            }
        } catch (IOException e) {
            e.printStackTrace();
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            try {
                if (os != null) {
                    os.close();
                }
                if (successResult != null) {
                    successResult.close();
                }
                if (errorResult != null) {
                    errorResult.close();
                }
            } catch (IOException e) {
                e.printStackTrace();
            }

            if (process != null) {
                process.destroy();
            }
        }
        return new CommandResult(result, successMsg == null ? null : successMsg.toString(), errorMsg == null ? null
                : errorMsg.toString());
    }

    /**
     * result of command
     * &lt;ul&gt;
     * &lt;li&gt;{@link CommandResult#result} means result of command, 0 means normal, else means error, same to excute in
     * linux shell&lt;/li&gt;
     * &lt;li&gt;{@link CommandResult#successMsg} means success message of command result&lt;/li&gt;
     * &lt;li&gt;{@link CommandResult#errorMsg} means error message of command result&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * @author &lt;a href="http://www.trinea.cn" target="_blank"&gt;Trinea&lt;/a&gt; 2013-5-16
     */
    public static class CommandResult {

        /** result of command **/
        public int    result;
        /** success message of command result **/
        public String successMsg;
        /** error message of command result **/
        public String errorMsg;

        public CommandResult(int result) {
            this.result = result;
        }

        public CommandResult(int result, String successMsg, String errorMsg) {
            this.result = result;
            this.successMsg = successMsg;
            this.errorMsg = errorMsg;
        }
    }
}
</code></pre>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
</div>

	</article>



	<article class="post">

		
			<h1><a href="/2016/12/27/%E5%AE%89%E5%8D%93%E8%93%9D%E7%89%99%E9%80%9A%E4%BF%A1/">安卓蓝牙通信</a></h1>
		

		<div class="post-content"><h3>开始</h3>
<pre><code>最近整理了一下在安卓系统下使用蓝牙收发数据的代码。蓝牙的操作，类似于网络socket的
使用。
首先我们需要获取蓝牙适配器，也就是BluetoothAdapter,通过BluetoothAdapter对蓝牙
进行操作。
流程如下：
获取BluetoothAdapter----->打开蓝牙------->搜索蓝牙设备------>绑定------>建立连接----
--->收发数据（通信）----->断开连接------>关闭蓝牙

完整代码地址
https://github.com/huijizyf/bluetoothchat.git
</code></pre>
<h3>界面效果</h3>
<pre><img src="http://donute.com/wp-content/uploads/2016/12/screenshot.jpg" alt="screenshot" width="720" height="1280" class="alignnone size-full wp-image-212" />
</pre>
<h3>关键代码</h3>
<pre><code>package com.donute.bluetoothchat;

import android.app.ProgressDialog;
import android.bluetooth.BluetoothAdapter;
import android.bluetooth.BluetoothDevice;
import android.bluetooth.BluetoothServerSocket;
import android.bluetooth.BluetoothSocket;
import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.support.v7.app.AppCompatActivity;
import android.os.Bundle;
import android.text.TextUtils;
import android.text.method.ScrollingMovementMethod;
import android.view.View;
import android.widget.AdapterView;
import android.widget.Button;
import android.widget.EditText;
import android.widget.ListView;
import android.widget.TextView;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import java.util.UUID;

import butterknife.Bind;
import butterknife.ButterKnife;

public class MainActivity extends AppCompatActivity implements View.OnClickListener, AdapterView.OnItemClickListener {
    /**
     * ******************************************控件定义******************************************
     */
    @Bind(R.id.btn_open_bluetooth_intent)
    Button btnOpenBluetoothIntent;
    @Bind(R.id.btn_open_bluetooth_silence)
    Button getBtnOpenBluetoothSilence;
    @Bind(R.id.lv_blue_devices_list)
    ListView lvDevicesList;
    @Bind(R.id.tv_data_received)
    TextView tvDataReceived;
    @Bind(R.id.et_data_to_send)
    EditText etDataToSend;
    @Bind(R.id.btn_send_data)
    Button btnSendData;
    @Bind(R.id.btn_close_bluetooth)
    Button btnCloseBluetooth;
    @Bind(R.id.btn_search_devices)
    Button btnSearchDevices;
    @Bind(R.id.btn_open_bluetooth_service)
    Button btnOpenService;
    @Bind(R.id.btn_bluetooth_disconnect)
    Button btnDisconnect;

    /**
     ******************************************变量声明*********************************************
     */
    private BluetoothAdapter mAdapter;               //蓝牙适配器
    private static final int REQUEST_CODE=1001;      //请求码，自定义整数即可
    private BluetoothServerSocket serverSocket;       //服务端连接套接字
    private BluetoothSocket clienSocket;               //客户端套接字
    private List&amp;lt;BluetoothDevice&amp;gt; deviceList;       //扫描接收到的蓝牙设备
    private DeviceViewAdapter viewAdapter;           //ListView的数据适配器
    private BluetoothSocket socket;                 //服务端套接字
    private static final UUID uuid=UUID.fromString(&amp;quot;00001101-0000-1000-8000-00805F9B34FB&amp;quot;);
    private int type=0;               //当前连接类型   1为服务端    2为客户端
    private DateFormat format;
    private ProgressDialog progressDialog;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        ButterKnife.bind(this);
        init();
    }

    /**
     * 初始化
     */
    private void init() {
        //设置TextView允许滚动
        tvDataReceived.setMovementMethod(ScrollingMovementMethod.getInstance());
        //获取蓝牙适配器
        mAdapter= BluetoothAdapter.getDefaultAdapter();
        if (mAdapter==null){
            TipManager.showDialog(this,&amp;quot;提示&amp;quot;,&amp;quot;当前设备不支持蓝牙&amp;quot;);
        }
        //日期字符串格式化
        format=new SimpleDateFormat(&amp;quot;yyyy-MM-dd HH:mm:ss&amp;quot;);
        //将已经绑定的设备加入列表中
        deviceList=new ArrayList&amp;lt;&amp;gt;(mAdapter.getBondedDevices());
        viewAdapter=new DeviceViewAdapter(this,deviceList);
        //给ListView设置数据适配器
        lvDevicesList.setAdapter(viewAdapter);
        //设置ListView点击事件处理
        lvDevicesList.setOnItemClickListener(this);

        //注册广播接收，会接收到开始扫描，扫描到设备，介绍扫描 三个事件，事件交由mReceiver处理

        IntentFilter filter = new IntentFilter();
        filter.addAction(BluetoothDevice.ACTION_FOUND);
        filter.addAction(BluetoothAdapter.ACTION_DISCOVERY_STARTED);
        filter.addAction(BluetoothAdapter.ACTION_DISCOVERY_FINISHED);
        registerReceiver(mReceiver, filter);

        //等待进度Dialog
        progressDialog=new ProgressDialog(this);
        progressDialog.setTitle(&amp;quot;请稍等&amp;quot;);
        progressDialog.setMessage(&amp;quot;正在扫描蓝牙设备，请稍等...&amp;quot;);
        progressDialog.setCancelable(false);

        //设置点击事件处理
        btnOpenBluetoothIntent.setOnClickListener(this);
        getBtnOpenBluetoothSilence.setOnClickListener(this);
        btnSendData.setOnClickListener(this);
        btnCloseBluetooth.setOnClickListener(this);
        btnSearchDevices.setOnClickListener(this);
        btnOpenService.setOnClickListener(this);
        btnDisconnect.setOnClickListener(this);
    }

    /**
     * 点击事件处理
     * @param v
     */
    @Override
    public void onClick(View v) {
        switch (v.getId()){
            case R.id.btn_open_bluetooth_intent:
                Intent enabler = new Intent(BluetoothAdapter.ACTION_REQUEST_ENABLE);
                startActivityForResult(enabler, REQUEST_CODE);      //调用系统弹框开启蓝牙
                break;
            case R.id.btn_open_bluetooth_silence:
                mAdapter.enable();//静默方式开启蓝牙
                break;
            case R.id.btn_send_data:
                sendData();     //发送数据
                break;
            case R.id.btn_close_bluetooth:
                mAdapter.disable(); //关闭蓝牙
                break;
            case R.id.btn_search_devices:
                if (mAdapter.isDiscovering()){  //开始扫描蓝牙，如果已经正在扫描了，则不继续执行
                    return;
                }
                deviceList.clear();
                mAdapter.startDiscovery();
                break;
            case R.id.btn_open_bluetooth_service:
                startServer(&amp;quot;my-service&amp;quot;);      //开启服务端
                break;
            case R.id.btn_bluetooth_disconnect:
                disconnect();                   //断开连接
                break;
        }
    }

    private void disconnect() {
        //根据当前类型断开连接
        switch (type){
            case 1:     //作为服务端
                try {
                    if (socket.isConnected())
                        socket.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
                break;
            case 2:     //作为客户端
                try {
                    if (clienSocket.isConnected())
                        clienSocket.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
                break;
        }
    }

    /**
     * 发送数据
     */
    private void sendData(){
        Thread sendThread=new Thread(){
            @Override
            public void run() {
                super.run();
                final String msg=etDataToSend.getText().toString();
                if (TextUtils.isEmpty(msg)){
                    runOnUiThread(new Runnable() {
                        @Override
                        public void run() {
                            TipManager.showDialog(MainActivity.this,&amp;quot;提示&amp;quot;,&amp;quot;内容为空，不能发送数据&amp;quot;);
                        }
                    });
                    return;
                }
                OutputStream os = null;
                try {
                    switch (type){
                        case 1:
                            if (socket!=null)
                                os=socket.getOutputStream();
                            break;
                        case 2:
                            if (clienSocket!=null)
                                 os=clienSocket.getOutputStream();
                            break;
                        default:
                            runOnUiThread(new Runnable() {
                                @Override
                                public void run() {
                                    TipManager.showDialog(MainActivity.this,&amp;quot;提示&amp;quot;,&amp;quot;还未建立连接，或者连接错误，不能发送数据&amp;quot;);
                                }
                            });
                            break;
                    }
                    if (os != null) {
                        //向输出流写入数据
                        os.write(msg.getBytes(&amp;quot;utf-8&amp;quot;));
                        tvDataReceived.post(new Runnable() {
                            @Override
                            public void run() {
                                //在UI线程操作界面，将发送的消息显示到界面，同时清空消息输入框
                                String m=tvDataReceived.getText().toString();
                                m=m+format.format(new Date())+&amp;quot;\t&amp;quot;+&amp;quot;发送：&amp;quot;+msg+&amp;quot;\n&amp;quot;;
                                tvDataReceived.setText(m);
                                etDataToSend.setText(&amp;quot;&amp;quot;);
                            }
                        });
                    }
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        };
        sendThread.start();
    }

    @Override
    protected void onDestroy() {
        super.onDestroy();
        //界面销毁时解除广播接收器的注册
        unregisterReceiver(mReceiver);
    }

    //定义广播接收器，接收与蓝牙相关的系统广播
    BroadcastReceiver mReceiver = new BroadcastReceiver() {
        public void onReceive(Context context, Intent intent) {
            String action = intent.getAction();
            //找到设备
            if (BluetoothDevice.ACTION_FOUND.equals(action)) {
                BluetoothDevice device = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
                if (device.getBondState()==BluetoothDevice.BOND_NONE){
                    deviceList.add(device);
                    progressDialog.setMessage(&amp;quot;正在扫描，已经扫描到设备数量：&amp;quot;+deviceList.size());
                    viewAdapter.notifyDataSetChanged();
                }
            }
            //扫描完成
            else if (BluetoothAdapter.ACTION_DISCOVERY_FINISHED.equals(action)) {
                progressDialog.dismiss();
                TipManager.showDialog(MainActivity.this,&amp;quot;提示&amp;quot;,&amp;quot;蓝牙设备扫描完成，总共扫描到蓝牙设备数量：&amp;quot;+deviceList.size());
                //开始扫描
            }else if (BluetoothAdapter.ACTION_DISCOVERY_STARTED.equals(action)){
                TipManager.showToast(MainActivity.this,&amp;quot;开始扫描设备&amp;quot;);
                progressDialog.show();
            }
        }
    };

    /**
     * 开启服务端
     */
    private void startServer(final String name){
        Thread serverThread=new Thread(){
            @Override
            public void run() {
                super.run();
                try {
                    type=1;
                    serverSocket = mAdapter. listenUsingRfcommWithServiceRecord(name,uuid);
                    socket=serverSocket.accept();      //等待服务端连接，accept函数为阻塞函数，会等待到有客户端连接成功后才会继续执行
                    InputStream is = socket.getInputStream();//客户端连接成功，获取输入流
                    while(true) {           //从输入流读取数据
                        byte[] buffer =new byte[1024];
                        int count = is.read(buffer);
                        final String s= new String(buffer, 0, count, &amp;quot;utf-8&amp;quot;);
                        tvDataReceived.post(new Runnable() {
                            @Override
                            public void run() {
                                //在UI线程操作界面，将接收到的消息显示到界面
                                String msg=tvDataReceived.getText().toString();
                                msg=msg+format.format(new Date())+&amp;quot;\t&amp;quot;+&amp;quot;接收：&amp;quot;+s+&amp;quot;\n&amp;quot;;
                                tvDataReceived.setText(msg);
                            }
                        });
                    }
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        };
        serverThread.start();
    }
    /**
     * 连接到服务端
     */
    private void connectServer(final BluetoothDevice device){
        final ProgressDialog dialog=new ProgressDialog(this);
        dialog.setTitle(&amp;quot;请稍等&amp;quot;);
        dialog.setMessage(&amp;quot;正在连接&amp;quot;);
        Thread connectThread=new Thread(){
            public void run(){
                super.run();
                try {
                    type=2;
                    clienSocket=device.createRfcommSocketToServiceRecord(uuid);
                    clienSocket.connect();
                    lvDevicesList.post(new Runnable() {
                        @Override
                        public void run() {
                            dialog.dismiss();
                            TipManager.showDialog(MainActivity.this,&amp;quot;提示&amp;quot;,&amp;quot;连接成功，现在可以发送数据了&amp;quot;);
                            startReceive();//连接到服务端成功，开启接收线程
                        }
                    });
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        };
        dialog.show();
        connectThread.start();
    }
    private void startReceive(){
        Thread receiveThread=new Thread(){
            @Override
            public void run() {
                super.run();
                try {
                    InputStream is=clienSocket.getInputStream();
                    if (is!=null){
                        while(true) {
                            byte[] buffer =new byte[1024];
                            int count = is.read(buffer);
                            final String s= new String(buffer, 0, count, &amp;quot;utf-8&amp;quot;);
                            tvDataReceived.post(new Runnable() {
                                @Override
                                public void run() {
                                    //在UI线程操作界面，将接收到的消息显示到界面
                                    String msg=tvDataReceived.getText().toString();
                                    msg=msg+format.format(new Date())+&amp;quot;\t&amp;quot;+&amp;quot;接收：&amp;quot;+s+&amp;quot;\n&amp;quot;;
                                    tvDataReceived.setText(msg);
                                }
                            });
                        }
                    }
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        };
        receiveThread.start();
    }

    @Override
    public void onItemClick(AdapterView&amp;lt;?&amp;gt; parent, View view, int position, long id) {
        BluetoothDevice device= (BluetoothDevice) viewAdapter.getItem(position);
        connectServer(device);
    }
}

</code></pre>
</div>

	</article>



	<article class="post">

		
			<h1><a href="/2016/12/23/%E5%AE%89%E5%8D%93%E8%BF%9C%E7%A8%8B%E6%97%A5%E5%BF%97%E6%94%B6%E9%9B%86/">安卓远程日志收集</a></h1>
		

		<div class="post-content"><h3>开始</h3>
<pre><code>最近在公司的项目中需要收集安卓的运行日志，最开始的时候我把日志写入到设备本地文件中存
储，使用Bmob的文件管理功能定时上传到服务器，在使用过程中有些地方不太方便，第一就是文
件上传过程中不能写入日志，不然会因为文件上传完成后的校验不通过，导致上传失败进而引发
程序崩溃。另外一个就是如果单纯的只为了收集日志的话引入Bmob的sdk有点过于浪费，Bmob
的SDK体积也并不小。
然后就开始自己动手解决这个问题。
</code></pre>
<h3>服务端实现</h3>
<pre><code>既然是远程收集日志，我们需要一个服务端程序，服务端的主要作用就是接受客户端传来的数
据，写入到文件中。我们选择了Python+web.py来实现。

import json
import web
import time
import sys
reload(sys)
sys.setdefaultencoding(&amp;#039;UTF-8&amp;#039;)     #设置字符编码

web.config.debug = True             #调试模式打开

urls = (
        &amp;#039;/&amp;#039;,&amp;#039;index&amp;#039;
    )

localLogs = &amp;quot;&amp;quot;


class index:

    def GET(self):                  #以网页形式返回日志数据

        htmlFormat = &amp;quot;&amp;lt;html&amp;gt;&amp;lt;head&amp;gt;&amp;lt;title&amp;gt;&amp;lt;/title&amp;gt;&amp;lt;/head&amp;gt;&amp;lt;body&amp;gt;%s   &amp;lt;script type=<pre wp-pre-tag-1></pre>amp;quot;text/javascript<pre wp-pre-tag-1></pre>amp;quot;&amp;gt;function myrefresh(){window.location.reload();window.scrollTo(0,document.body.scrollHeight);}setTimeout(&amp;#039;myrefresh()&amp;#039;,1000); &amp;lt;/script&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;&amp;quot;
        global localLogs
        # localLogs = localLogs.encode(&amp;#039;gbk&amp;#039;)
        return htmlFormat % localLogs

    def POST(self):                 #接收请求保存日志到文件

        inputs=web.input()
        content = web.data()        #接收到日志数据

        if content.startswith(&amp;#039;{&amp;#039;) and content.endswith(&amp;#039;}&amp;#039;):
            content = &amp;#039;[&amp;#039; + content + &amp;#039;]&amp;#039;           #以Json数组格式处理

        print content
        logs = json.loads(content)

        for log in logs:                            #处理数组中的log元素
            if &amp;#039;stack&amp;#039; not in log:
                log[&amp;#039;stack&amp;#039;] = &amp;quot; &amp;quot;

            color = &amp;#039;#808080&amp;#039;                       #根据日志级别不同，以不同颜色显示到网页
            if log[&amp;#039;level&amp;#039;] == &amp;#039;INFO&amp;#039;:
                color = &amp;#039;#008000&amp;#039;
            elif log[&amp;#039;level&amp;#039;] == &amp;#039;WARNING&amp;#039;:
                color = &amp;#039;#FFA500&amp;#039;
            elif log[&amp;#039;level&amp;#039;] == &amp;#039;ERROR&amp;#039;:
                color = &amp;#039;#FF0000&amp;#039;

            strLog = &amp;#039;&amp;lt;div style=&amp;quot;color:%s&amp;quot;&amp;gt;%s  %s: [%s] %s &amp;lt;/div&amp;gt;&amp;#039; % (color, log[&amp;#039;time&amp;#039;],log[&amp;#039;level&amp;#039;], log[&amp;#039;tag&amp;#039;], log[&amp;#039;msg&amp;#039;])#日志内容

            stacks = log[&amp;#039;stack&amp;#039;].split(&amp;#039;\n&amp;#039;)
            strLog = strLog + (&amp;#039;&amp;lt;div color=&amp;quot;%s&amp;quot;&amp;gt;&amp;#039; % color)
            for s in stacks:
                strLog = strLog + (&amp;#039;&amp;lt;div&amp;gt;%s&amp;lt;/div&amp;gt;&amp;#039; % (s.strip()))

            strLog = strLog + &amp;#039;&amp;lt;/div&amp;gt;&amp;#039;

            fileName=&amp;quot;logs/&amp;quot;+log[&amp;#039;boxId&amp;#039;]+&amp;quot;_&amp;quot;+time.strftime(&amp;#039;%Y-%m-%d&amp;#039;)+&amp;quot;.html&amp;quot;
            f=open(fileName,&amp;#039;a&amp;#039;)                        #以追加方式写文件
            f.write(strLog+&amp;quot;\n&amp;quot;)
            f.close()
            global localLogs
            localLogs = localLogs + strLog

        return &amp;quot;&amp;quot;


if __name__ == &amp;#039;__main__&amp;#039;:
    app = web.application(urls, globals())
    app.run()
</code></pre>
<h3>安卓端实现</h3>
<h4>首先定义一个日志接口</h4>
<pre><code>public interface ILog {

    public void d(String tag, String msg);
    public void i(String tag, String msg);
    public void w(String tag, String msg);
    public void w(String tag, String msg, Throwable e);
    public void e(String tag, String msg);
    public void e(String tag, String msg, Throwable e);

    public void destory();
}
</code></pre>
<h4>远程日志实现接口</h4>
<pre><code>public class URemoteLog implements ILog{


    private URemoteLogPrinter printer;

    public URemoteLog(int interval){
        printer = new URemoteLogPrinter(interval);
    }

    @Override
    public void d(String tag, String msg) {
        printer.print(new ULog(ULog.L_DEBUG, tag, msg));
    }

    @Override
    public void i(String tag, String msg) {
        printer.print(new ULog(ULog.L_INFO, tag, msg));
    }

    @Override
    public void w(String tag, String msg) {
        printer.print(new ULog(ULog.L_WARN, tag, msg));
    }

    @Override
    public void w(String tag, String msg, Throwable e) {
        printer.print(new ULog(ULog.L_WARN, tag, msg));
    }

    @Override
    public void e(String tag, String msg) {
        printer.print(new ULog(ULog.L_ERROR, tag, msg));
    }

    @Override
    public void e(String tag, String msg, Throwable e) {
        printer.print(new ULog(ULog.L_ERROR, tag, msg));
    }

    @Override
    public void destory() {
        printer.stop();
    }

}
</code></pre>
<h4>日志打印类，主要将日志写入远程</h4>
<pre><code>public class URemoteLogPrinter {

    private List&amp;lt;ULog&amp;gt; logs;
    private int interval = 1000; //单位 毫秒

    private Timer timer;
    private boolean running;

    public URemoteLogPrinter(){
    }

    public URemoteLogPrinter(int interval){
        this.logs = Collections.synchronizedList(new ArrayList&amp;lt;ULog&amp;gt;());
        this.interval = interval;
    }

    public void print(ULog log){
        start();
        synchronized (logs) {
            logs.add(log);
        }
    }

    public void printImmediate(String log){
        HttpService.reportLog(log, new HttpCallback&amp;lt;String&amp;gt;() {
            @Override
            public void onSuccess(String data) {

            }
            @Override
            public void onFailure(int statusCode, Error error) {

            }
        });
    }

    public List&amp;lt;ULog&amp;gt; getAndClear(){
        synchronized (logs) {
            List&amp;lt;ULog&amp;gt; all = new ArrayList&amp;lt;ULog&amp;gt;(logs);
            logs.clear();
            return all;
        }
    }

    public void start(){
        if(running){
            return;
        }

        running = true;
        TimerTask task = new LogPrintTask();
        timer = new Timer(true);
        timer.scheduleAtFixedRate(task, 100, interval);
    }

    public void stop(){
        if(timer != null){
            timer.cancel();
        }
        running = false;
    }

    class LogPrintTask extends TimerTask{
        @Override
        public void run() {
            try{
                List&amp;lt;ULog&amp;gt; logs = getAndClear();
                if(logs.size() &amp;gt; 0){
                    StringBuilder sb = new StringBuilder();
                    sb.append(&amp;quot;[&amp;quot;);
                    for(ULog log : logs){
                        sb.append(log.toJson()).append(&amp;quot;,&amp;quot;);
                    }
                    sb.deleteCharAt(sb.length()-1).append(&amp;quot;]&amp;quot;);
                    HttpService.reportLog(sb.toString(), new HttpCallback&amp;lt;String&amp;gt;() {
                        @Override
                        public void onSuccess(String data) {

                        }
                        @Override
                        public void onFailure(int statusCode, Error error) {

                        }
                    });
                }
            }catch(Exception e){
                e.printStackTrace();
                stop();
            }
        }

    }
}

</code></pre>
<h4>日志实体类</h4>
<pre><code>public class ULog {
    public static final String L_DEBUG=&amp;quot;L_DEBUG&amp;quot;;
    public static final String L_INFO=&amp;quot;L_INFO&amp;quot;;
    public static final String L_WARN=&amp;quot;L_WARN&amp;quot;;
    public static final String L_ERROR=&amp;quot;L_ERROR&amp;quot;;

    private String boxId;
    private String level;
    private String msg;
    private String tag;
    private String time;

    public ULog(String level,String tag,String msg) {
        this.boxId = MainApplication.getBoxId();
        this.level = level;
        this.msg = msg;
        this.tag = tag;
        Date date=new Date();
        SimpleDateFormat format=new SimpleDateFormat(&amp;quot;yyyy-MM-dd HH:mm:ss&amp;quot;);
        String time=format.format(date);
        this.time = time;
    }
    public String toJson(){
        Gson gson=new Gson();
        return gson.toJson(this);
    }
}
</code></pre>
</div>

	</article>



	<article class="post">

		
			<h1><a href="/2016/12/16/Android%E5%BC%80%E5%8F%91%E4%B8%AD%E4%B8%80%E4%BA%9B%E8%A2%AB%E5%86%B7%E8%90%BD%E4%BD%86%E5%8D%B4%E5%BE%88%E6%9C%89%E7%94%A8%E7%9A%84%E7%B1%BB%E5%92%8C%E6%96%B9%E6%B3%95/">Android开发中一些被冷落但却很有用的类和方法</a></h1>
		

		<div class="post-content"><p>MediaMetadataRetriever<br />
顾名思义，就是用来获取媒体文件一些相关信息的类。包括一首歌的标题，作者，专辑封面和名称，时长，比特率等等。如果是视频的话，可以获取视频的长宽，预览图。</p>
<p>http://developer.android.com/intl/zh-cn/reference/android/media/MediaMetadataRetriever.html</p>
<p>TouchDelegate<br />
用于更改View的触摸区域。场景：比如在RecyclerView的ItemView里包含了CheckBox组件, 然后想实现点击ItemView的时候，也可以触发CheckBox，就可以使用此类。</p>
<p>http://developer.android.com/intl/zh-cn/training/gestures/viewgroup.html#delegate</p>
<p>ArgbEvaluator<br />
用于计算不同颜色值之间的插值，配合ValueAnimator.ofObject或者ViewPager.PageTransformer使用，可以实现不同颜色之间的平滑过渡。</p>
<p>http://developer.android.com/intl/zh-cn/reference/android/animation/ArgbEvaluator.html</p>
<p>Palette<br />
用于提取一张图片的颜色。</p>
<p>http://developer.android.com/intl/zh-cn/reference/android/support/v7/graphics/Palette.html</p>
<p>ViewDragHelper<br />
做过自定义ViewGroup的童鞋都应该知道这个东西吧，用来处理触摸事件的神器，妈妈再也不用担心我自定义控件了。</p>
<p>http://developer.android.com/intl/zh-cn/reference/android/support/v4/widget/ViewDragHelper.html</p>
<p>http://www.cnblogs.com/lqstayreal/p/4500219.html</p>
<p>PageTransformer<br />
用于定义ViewPager页面切换时的动画效果（淡入淡出，放大缩小神马的…）官方有例子，直接看吧。</p>
<p>http://developer.android.com/intl/zh-cn/training/animation/screen-slide.html</p>
<p>ViewFlipper<br />
可以实现简单轮播效果的一个组件。</p>
<p>http://developer.android.com/intl/zh-cn/reference/android/widget/ViewFlipper.html</p>
<p>LocalBroadcastManager<br />
用于在APP内部使用的，效率和安全性更好的广播工具类。</p>
<p>http://developer.android.com/intl/zh-cn/reference/android/support/v4/content/LocalBroadcastManager.html</p>
<p>Messenger<br />
进程间通信的一个工具类。内部也是由AIDL实现的，但是用起来超级方便。</p>
<p>http://developer.android.com/intl/zh-cn/reference/android/os/Messenger.html</p>
<p>http://blog.csdn.net/lmj623565791/article/details/47017485</p>
<p>Formatter.formatFileSize<br />
根据文件大小自动转为以KB, MB, GB为单位的工具类。想想以前都是自己计算的…</p>
<p>http://developer.android.com/intl/zh-cn/reference/android/text/format/Formatter.html</p>
<p>Activity.recreate<br />
重新创建Activity。有什么用呢？可以在程序更换主题后，立马刷新当前Activity，而不会有明显的重启Activity的动画。</p>
<p>http://developer.android.com/intl/zh-cn/reference/android/app/Activity.html#recreate%28%29</p>
<p>View.getContext<br />
顾名思义，就不用解释了吧…以前在写RecyclerView的Adapter的时候，为了使用LayoutInflater，经常傻乎乎地在构造函数中传入一个外部的context….是不是只有我不知道而已（笑cry脸）</p>
<p>http://developer.android.com/intl/zh-cn/reference/android/view/View.html#getContext()</p>
<p>View.post<br />
方便在非UI线程对界面进行修改，与Handler的作用类似。并且由于post的Runnable会保证在该View绘制完成的前提下才调用，所以一般也可以用于获取View的宽高。</p>
<p>http://developer.android.com/intl/zh-cn/reference/android/view/View.html#post(java.lang.Runnable)</p>
<p>Activity.runOnUiThread<br />
与View.post类似，方便在非UI线程中对界面进行修改。</p>
<p>http://developer.android.com/intl/zh-cn/reference/android/app/Activity.html#runOnUiThread(java.lang.Runnable)</p>
<p>Fragment.setUserVisibleHint<br />
Fragment可以重写此方法，然后根据参数的布尔值（true的话表示当前Fragment对用户可见），来执行一些逻辑。</p>
<p>http://developer.android.com/intl/zh-cn/reference/android/support/v4/app/Fragment.html#setUserVisibleHint(boolean)</p>
<p>android:animateLayoutChanges<br />
这是一个非常酷炫的属性。在父布局加上android:animateLayoutChanges="true"后，如果触发了layout方法（比如它的子View设置为GONE），系统就会自动帮你加上布局改变时的动画特效！！</p>
<p>http://developer.android.com/intl/zh-cn/training/animation/layout.html</p>
<p>android:clipToPadding<br />
设置父view是否允许其子view在它的padding（这里指的是父View的padding）中绘制。是不是有点绕？举个实际场景吧：假如有个ListView，我们想要在初始位置时，第一项Item离顶部有10dp的距离，就可以在ListView的布局中加入android:clipToPadding="false"android:paddingTop="10dp"即可。是不是很方便呢？</p>
<p>http://developer.android.com/intl/zh-cn/reference/android/view/ViewGroup.html#attr_android:clipToPadding</p>
</div>

	</article>



	<article class="post">

		
			<h1><a href="/2016/12/12/java%E5%AE%9E%E7%8E%B0%E8%8E%B7%E5%8F%96%E6%96%87%E4%BB%B6MD5/">java实现获取文件MD5值</a></h1>
		

		<div class="post-content"><h3>什么是MD5</h3>
<pre><code>Message Digest Algorithm MD5（中文名为消息摘要算法第五版）为计算机安全领域广泛
使用的一种散列函数，用以提供消息的完整性保护。该算法的文件号为RFC 
1321（R.Rivest,MIT Laboratory for Computer Science and RSA Data 
Security Inc. April 1992）。
MD5即Message-Digest Algorithm 5（信息-摘要算法5），用于确保信息传输完整一致。
是计算机广泛使用的杂凑算法之一（又译摘要算法、哈希算法），主流编程语言普遍已有MD5实
现。将数据（如汉字）运算为另一固定长度值，是杂凑算法的基础原理，MD5的前身有MD2、MD3和MD4。

MD5算法具有以下特点：
1、压缩性：任意长度的数据，算出的MD5值长度都是固定的。
2、容易计算：从原数据计算出MD5值很容易。
3、抗修改性：对原数据进行任何改动，哪怕只修改1个字节，所得到的MD5值都有很大区别。
4、强抗碰撞：已知原数据和其MD5值，想找到一个具有相同MD5值的数据（即伪造数据）是非常困难的。
MD5的作用是让大容量信息在用数字签名软件签署私人密钥前被&amp;quot;压缩&amp;quot;成一种保密的格式（就是
把一个任意长度的字节串变换成一定长的十六进制数字串）。除了MD5以外，其中比较有名的还
有sha-1、RIPEMD以及Haval等。
</code></pre>
<h3>发展历史</h3>
<pre><code>MD2
Rivest在1989年开发出MD2算法。在这个算法中，首先对信息进行数据补位，使信息的字节长度是16的倍数。然后，以一个16位的检验和追加到信息末尾，并且根据这个新产生的信息计算出散列值。后来，Rogier和Chauvaud发现如果忽略了检验将和MD2产生冲突。MD2算法加密后结果是唯一的（即不同信息加密后的结果不同）。
MD4
为了加强算法的安全性，Rivest在1990年又开发出MD4算法。MD4算法同样需要填补信息以确
保信息的比特位长度减去448后能被512整除（信息比特位长度mod 512 = 448）。然后，一个
以64位二进制表示的信息的最初长度被添加进来。信息被处理成512位damg?rd/merkle迭代结
构的区块，而且每个区块要通过三个不同步骤的处理。Den boer和Bosselaers以及其他人很
快的发现了攻击MD4版本中第一步和第三步的漏洞。Dobbertin向大家演示了如何利用一部普通
的个人电脑在几分钟内找到MD4完整版本中的冲突（这个冲突实际上是一种漏洞，它将导致对不
同的内容进行加密却可能得到相同的加密后结果）。毫无疑问，MD4就此被淘汰掉了。
尽管MD4算法在安全上有个这么大的漏洞，但它对在其后才被开发出来的好几种信息安全加密算
法的出现却有着不可忽视的引导作用。
MD5
1991年，Rivest开发出技术上更为趋近成熟的md5算法。它在MD4的基础上增加了&amp;quot;安全-带
子&amp;quot;（safety-belts）的概念。虽然MD5比MD4复杂度大一些，但却更为安全。这个算法很明显
的由四个和MD4设计有少许不同的步骤组成。在MD5算法中，信息-摘要的大小和填充的必要条件
与MD4完全相同。Den boer和Bosselaers曾发现MD5算法中的假冲突（pseudo-
collisions），但除此之外就没有其他被发现的加密后结果了。
</code></pre>
<h3>使用java语言获取文件MD5</h3>
<pre><code>/**
 * MD5验证工具 
 *
 */
public class MD5Util {

    /**
     * 默认的密码字符串组合，用来将字节转换成 16 进制表示的字符,apache校验下载的文件的正确性用的就是默认的这个组合 
     */
    protected static char hexDigits[] = {&amp;#039;0&amp;#039;,&amp;#039;1&amp;#039;,&amp;#039;2&amp;#039;,&amp;#039;3&amp;#039;,&amp;#039;4&amp;#039;,&amp;#039;5&amp;#039;,&amp;#039;6&amp;#039;,&amp;#039;7&amp;#039;,&amp;#039;8&amp;#039;,&amp;#039;9&amp;#039;,&amp;#039;a&amp;#039;,&amp;#039;b&amp;#039;,&amp;#039;c&amp;#039;,&amp;#039;d&amp;#039;,&amp;#039;e&amp;#039;,&amp;#039;f&amp;#039;};
    protected static MessageDigest messagedigest = null;
    static {
        try {
            messagedigest = MessageDigest.getInstance(&amp;quot;MD5&amp;quot;);
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
        }
    }

    public static String getFileMD5String(File file) throws IOException {
        InputStream fis;
        fis = new FileInputStream(file);
        byte[] buffer = new byte[1024];
        int numRead = 0;
        while ((numRead = fis.read(buffer)) &amp;gt; 0) {
            messagedigest.update(buffer, 0, numRead);
        }
        fis.close();
        return bufferToHex(messagedigest.digest());
    }

    private static String bufferToHex(byte bytes[]) {
        return bufferToHex(bytes, 0, bytes.length);
    }

    private static String bufferToHex(byte bytes[], int m, int n) {
        StringBuffer stringbuffer = new StringBuffer(2 * n);
        int k = m + n;
        for (int l = m; l &amp;lt; k; l++) {
            appendHexPair(bytes[l], stringbuffer);
        }
        return stringbuffer.toString();
    }

    private static void appendHexPair(byte bt, StringBuffer stringbuffer) {
        char c0 = hexDigits[(bt &amp;amp; 0xf0) &amp;gt;&amp;gt; 4];// 取字节中高 4 位的数字转换  
        // 为逻辑右移，将符号位一起右移,此处未发现两种符号有何不同  
        char c1 = hexDigits[bt &amp;amp; 0xf];// 取字节中低 4 位的数字转换  
        stringbuffer.append(c0);
        stringbuffer.append(c1);
    }
}  
</code></pre>
</div>

	</article>



	<article class="post">

		
			<h1><a href="/2016/12/07/%E5%A6%82%E4%BD%95%E5%9C%A8Linux%E4%B8%AD%E6%9F%A5%E6%89%BE%E4%B8%80%E4%B8%AA%E6%96%87%E4%BB%B6/">如何在Linux中查找一个文件</a></h1>
		

		<div class="post-content"><p>在Linux中查找文件有两种方法。一种是使用 find 命令，另外一种是使用 locate 命令。我们先看第一种。<br />
find命令使用 Linux find命令可以用不同的搜索标准如名字、类型、所属人、大小等来搜索目录树。基本语法如下：</p>
<h1>find path expression search-term</h1>
<p>下面是使用find命令根据文件名来查找特定文件的一个例子：</p>
<h1>find -name test.file</h1>
<p>命令会搜索整个目录树来查找名为 test.file 的文件，并且会提供其存放位置。你可以使用你Linux上一个存在的文件名来尝试一下。<br />
find命令有时会花费几分钟来查找整个目录树，尤其是如果系统中有很多文件和目录的话。要显著减少时间，你可以指定搜索的目录。比如，如果你知道 /var 中存在 test.file，那就没有必要搜索其它目录。这样，你可以使用下面的命令：</p>
<h1>find /var -name test.file</h1>
<p>find还可以根据时间、大小、所属人、权限等选项搜索文件。要了解更多关于这些选项的信息，你可以使用查看** Linux find命令**的手册。</p>
<h1>man find</h1>
<p>locate命令<br />
要在Linux中使用locate命令，首先需要安装它。<br />
如果你正在使用Ubuntu，运行下面的命令来安装locate：</p>
<h1>apt-get update</h1>
<h1>apt-get install mlocate</h1>
<p>如果你使用的是CentOS，运行下面的命令来安装locate：</p>
<h1>yum install mlocate</h1>
<p>locate是一种比find更快的方式，因为它在数据库中查找文件。要更新搜索数据库，运行下面的命令：</p>
<h1>updatedb</h1>
<p>使用locate查找文件的语法：</p>
<h1>locate test.file</h1>
<p>就像find命令一样，locate也有很多选项来过滤输出。要了解更多你可以查看Linux Locate命令的手册。</p>
<h1>man locate</h1>
</div>

	</article>






	<div class="postnavigation">

		
			<span class="nope left">&larr; Newer</span>
		

		<span class="pages">Page 1 of 6</span>

		
			<a class="next right" href="/page2/">Older &rarr;</a>
		

	</div>

    </div>



  </div>



  <footer id="footer">
    <p class="copyright">Copyright &copy; 2017 Solar Theme. Powered by <a href="http://jekyllrb.com">Jekyll</a>, theme by <a href="http://www.webmaster-source.com">Matt Harzewski</a></p>
  </footer>



  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.10.1/jquery.min.js"></script>
  <script src="/assets/js/jquery.mobilemenu.min.js"></script>

  <script>
    $(document).ready(function(){
      $('#sidebar nav ul').mobileMenu({'topOptionText': 'Menu', 'prependTo': '#sidebar nav'});
    });
  </script>



</body>
</html>